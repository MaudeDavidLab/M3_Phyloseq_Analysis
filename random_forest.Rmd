---
title: "random_forest"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
setwd("C:/Users/ctata/Documents/Lab/M3_longitudinal/M3_Phyloseq_Analysis")
library(caret)
library(randomForest)
library(tibble)
library(ROCR)
library(dplyr)
library(reshape2)
library(phyloseq)
library(glmnet)
source('clean_mapping_ml.R')
```

# Load data
```{r}
output_data <- "results/"
ps_deseq <- readRDS(paste0(output_data, "Filtered/ps_deseq_friedfilt.rds"))
ps_css <- readRDS(paste0(output_data, "Filtered/ps_css_friedfilt.rds"))
sig_res <- read.csv(paste0(output_data, "Significant_res_deseq_q0.05_mtgseq_q0.05_tax.csv"), row.names = 1)
```

### metadata for ML
```{r echo = F, results = 'hide'}

map_keep <- keepImportantColumns(ps_deseq@sam_data, metabol = F)
rownames(map_keep) <- map_keep$biospecimen_id
map_num <- makeFieldsNumeric(map_keep)
map_num <- map_num %>% select(-c(MARA, date))
nums <- as.vector(unlist(lapply(map_num, is.numeric)) )
map_num[, !nums] <- lapply(map_num[, !nums], factor)
map_num$stool_freq <- as.numeric(map_num$stool_freq)
sample_data(ps_deseq) <- map_num

```

### Random Forest

```{r randomforest}
#Random Forest main function
rand_forest <- function(pred_sequences, ps, include_taxa = T, include_meta = F){ 
  set.seed(1)
  phen <- sample_data(ps)$phenotype
  fam_id <- sample_data(ps)$familyID
  data <- NULL
  if(include_taxa){
    ps <- prune_taxa(pred_sequences, ps )
    data <- t(otu_table(ps))
    colnames(data) <- tax_table(ps)[,7]
  }
  if(include_meta){
    metadata <- data.frame(ps@sam_data)
    metadata <- metadata %>% select(-c(familyID, biospecimen_id, biospecimen_name, host_name, timepoint, age, dietary_restriction, dietary_supplement, sex, probiotic, vitamin_B, vitamin_D, multivitamin, racial_group))
    metadata <- rfImpute(phenotype ~., metadata)
    metadata <- metadata %>% select(-c(phenotype))
    if(is.null(data)){
      data <- metadata
    }else{
      data <- data.frame(cbind(data, metadata))
    }
  }
  data <- data.frame(phen, data, fam_id)
  
  
  folds_by_family <- groupKFold(fam_id, 5)
  data <- data %>% select(-c(fam_id))
  
  validate <- data[-folds_by_family[[1]],]
  training <- data[folds_by_family[[1]],]
  

  
  control <- trainControl(method='repeatedcv', 
                        number=3, 
                        repeats=3)

  tree_depths <- round(seq(2, ncol(data), by = ncol(data) / 6))
  tunegrid <- expand.grid(.mtry= tree_depths) #mtry is the depth of each decision tree
  
  rf <- train(phen ~., 
            data = training, 
            method='rf', 
            metric='Accuracy', 
            tuneGrid=tunegrid, 
            trControl=control)


  mtry_best = as.numeric(rf$bestTune)
  print(paste0("Tree depth: ", mtry_best))

  pred_votes <- c()
  outputlist <- list()
  for(i in 1:5){
    AR.classify <- randomForest(phen~., data = training, ntree = 128, mtry = mtry_best, importance = TRUE)
    rf <- AR.classify
    OOB.votes <- predict(rf, validate[,-1], type="prob");
    OOBpred_votes <- OOB.votes
  
    pred_votes <-  OOBpred_votes[,2]
    pred.obj <- prediction(pred_votes, data[names(pred_votes), ]$phen)
    
    #roc (tpr / fpr) perforamnce 
    roc_perf <- performance(pred.obj,"tpr", "fpr") #Calculate the AUC value
    auc_roc <- performance(pred.obj, "auc")@y.values[[1]]
    
    
    perf_obj <-list()
    perf_obj[[1]] <- auc_roc
    perf_obj[[2]] <- roc_perf
    perf_obj[[3]] <- rf
    outputlist[[i]] <- perf_obj
  }
  return(outputlist)
}
```



```{r}
plotAUCs <- function(perf_obj, col_ind = 1, plot_name = ""){
  avg_auc <- mean(unlist(lapply(perf_obj, function(x) return(x[[1]]))))
  plot(perf_obj[[1]][[2]], col = rainbow(8)[col_ind])
  for(i in 2:length(perf_obj)){
    plot(perf_obj[[i]][[2]], col = rainbow(8)[col_ind], add = T)   
  }
  abline(a=0, b= 1)
  text(.9, .1, paste0("AUC: ", round(avg_auc, 3)))
  title(plot_name)
  print(avg_auc)
}
```

### Just metadata
```{r fig.height = 3, fig.width=5, echo = F}
use <- as.numeric(apply(sig_res, 1, function(x) return(sum(!is.na(x))))) > 0
perf_obj_meta <- rand_forest(pred_sequences = rownames(sig_res)[use], ps = ps_deseq, include_taxa = F, include_meta = T)
plotAUCs(perf_obj_meta, 1, "Just Metadata")
```

```{r, fig.height = 6, fig.width = 7}
varImpPlot(perf_obj_meta[[1]][[3]])
```

### Metadata and taxa selected once
```{r fig.height = 3, fig.width=5}
use <- as.numeric(apply(sig_res, 1, function(x) return(sum(!is.na(x))))) > 0
perf_obj_0 <- rand_forest(pred_sequences = rownames(sig_res)[use], ps = ps_deseq, include_taxa = T, include_meta = T)
plotAUCs(perf_obj_0, 2, 'All taxa and metadata')
```

### Metadata and taxa selected twice
```{r fig.height = 3, fig.width=5}
use <- as.numeric(apply(sig_res, 1, function(x) return(sum(!is.na(x))))) > 1
perf_obj_1 <- rand_forest(pred_sequences = rownames(sig_res)[use], ps = ps_deseq, include_taxa = T, include_meta = T)
plotAUCs(perf_obj_1, 3, "Taxa > 1 and metadata")
```

### Metadata and taxa selected three times
```{r, fig.height = 3, fig.width=5}
use <- as.numeric(apply(sig_res, 1, function(x) return(sum(!is.na(x))))) > 2
perf_obj_2 <- rand_forest(pred_sequences = rownames(sig_res)[use], ps = ps_deseq, include_taxa = T, include_meta = T)
plotAUCs(perf_obj_2, 4, "Taxa > 2 and metadata")
```

### Metadata and taxa selected 4 times
```{r, fig.height = 3, fig.width=5}
use <- as.numeric(apply(sig_res, 1, function(x) return(sum(!is.na(x))))) > 3
perf_obj_3 <- rand_forest(pred_sequences = rownames(sig_res)[use], ps = ps_deseq, include_taxa = T, include_meta = T)
plotAUCs(perf_obj_3, 5, "Taxa > 4 and metadata")
```

### Metadata and taxa in either timeseries 
```{r, fig.height = 3, fig.width=5}
use <- !is.na(sig_res$deseq_timeseries_adjp) | !is.na(sig_res$mtgseq_timeseries_adjp)
perf_obj_time <- rand_forest(pred_sequences = rownames(sig_res)[use], ps = ps_deseq, include_taxa = T, include_meta = T)
plotAUCs(perf_obj_time, 6, "Taxa either timeseries and metadata")
```

```{r fig.height = 7, fig.width = 9}
varImpPlot(perf_obj_time[[1]][[3]])
```

### Metadata and taxa in both timeseries 
```{r, fig.height = 3, fig.width=5}
use <- !is.na(sig_res$deseq_timeseries_adjp) & !is.na(sig_res$mtgseq_timeseries_adjp)
perf_obj_time_both <- rand_forest(pred_sequences = rownames(sig_res)[use], ps = ps_deseq, include_taxa = T, include_meta = T)
plotAUCs(perf_obj_time_both, 7, "Taxa timeseries and metadata")
```

### All significant taxa without metadata
```{r, fig.height = 3, fig.width=5}
perf_obj_allsig <- rand_forest(pred_sequences = rownames(sig_res), ps = ps_deseq, include_taxa = T, include_meta = F)
plotAUCs(perf_obj_allsig, 1, "All Sig Taxa")
```

### Taxa in either timeseries without metadata
```{r, fig.height = 3, fig.width=5}
use <- !is.na(sig_res$deseq_timeseries_adjp) | !is.na(sig_res$mtgseq_timeseries_adjp)
perf_obj_allsig <- rand_forest(pred_sequences = rownames(sig_res)[use], ps = ps_deseq, include_taxa = T, include_meta = F)
plotAUCs(perf_obj_allsig, 2, "All Sig Taxa")
```



### Variance in phenotype explained by most informative taxa by logistic regression
```{r}
runLogisticRegression <- function(pred_sequences, ps){
  set.seed(1)
  ps <- prune_taxa(pred_sequences, ps )
  folds_by_family <- groupKFold(ps@sam_data$familyID, 5)
  train <- t(ps@otu_table[, -folds_by_family[[1]]])
  test <- t(ps@otu_table[, folds_by_family[[1]]])
  train_y <- ps@sam_data$phenotype[-folds_by_family[[1]]]
  test_y <- ps@sam_data$phenotype[folds_by_family[[1]]]
  cvfit <- cv.glmnet(as.matrix(train), train_y, family = "binomial")
  preds <- predict(cvfit, test, s = 'lambda.min')
  pred.obj <- prediction(preds, test_y)
      
    #roc (tpr / fpr) perforamnce 
  roc_perf <- performance(pred.obj,"tpr", "fpr") #Calculate the AUC value
  auc_roc <- performance(pred.obj, "auc")@y.values[[1]]
  print(auc_roc)
}


```

```{r}
runLogisticRegression(taxa_names(ps_deseq), ps_deseq)
```

```{r}
use <- as.numeric(apply(sig_res, 1, function(x) return(sum(!is.na(x))))) > 0
runLogisticRegression(rownames(sig_res)[use], ps_deseq)
```

```{r}
use <- as.numeric(apply(sig_res, 1, function(x) return(sum(!is.na(x))))) > 1
runLogisticRegression(rownames(sig_res)[use], ps_deseq)
```

```{r}
use <- !is.na(sig_res$deseq_timeseries_adjp) & !is.na(sig_res$mtgseq_timeseries_adjp)
runLogisticRegression(rownames(sig_res)[use], ps_deseq)
```
```{r}
use <- !is.na(sig_res$deseq_timeseries_adjp) | !is.na(sig_res$mtgseq_timeseries_adjp)
runLogisticRegression(rownames(sig_res)[use], ps_deseq)
```


### Stool frequency
```{r fig.height = 3, fig.width=3}
aut <- ps_deseq@sam_data$phenotype == "A"
nt <- ps_deseq@sam_data$phenotype == "N"
boxplot(ps_deseq@sam_data$stool_freq[aut], ps_deseq@sam_data$stool_freq[nt])
```


### Heat Map
```{r heat map, fig.height = 10}
ps_tss <- readRDS("results/Normalized/ps_tss_pass_min_postDD_min0.03.rds")
# Heatmap EXPERIMENTAL STAGE
heatmap <- ps_tss@otu_table[rownames(sig_res),]
heatlabel <- gsub("g__","",sig_res$Genus)
for (x in 1:70){
  if (heatlabel[x] == "unclassified"){
    heatlabel[x]<-paste(gsub("c__", "", sig_res$Class[x]), heatlabel[x], sep = "_")
  }
  heatlabel[x] <- paste(heatlabel[x], x, sep = ".")
}

rownames(heatmap) <- heatlabel
heatmap<-as.data.frame(heatmap)
heatmap <- t(heatmap)
heatmap<-as.data.frame(heatmap)
heatmap$Sample <- rownames(heatmap)
heatmap$Phenotype <- ps_tss@sam_data$phenotype
heatmap_below0.5 <- heatmap
maxes<-list()
for (x in c(1:70)){
   maxes[x]<-max(heatmap_below0.5[,x])
}
heatmap_below0.5 <- heatmap[,-which(maxes >= 0.002)]

heatmelt <-melt(heatmap_below0.5, value.name = "Abundance")
ggplot(heatmelt, aes(Sample, variable, fill= Abundance)) + 
  geom_tile() + 
  facet_grid(~ Phenotype,switch = "x", scales = "free_x", space = "free_x") +
  scale_fill_gradient(name = "Abundance",
                      low = "#FFFFFF",
                      high = "#012345")



```