---
title: "Phase I report analysis"
author: "Maude David & Shoko Iwai and updated by Austin Martin"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) { rmarkdown::render(inputFile, encoding = encoding, output_file = paste0(substr(inputFile,1,nchar(inputFile)-4),'_',Sys.Date(),'.html')) })
output:
  html_document:
    number_sections: true
    toc: true
    toc_float: true
---

# Setup
## Load libraries
```{r cache=FALSE, include=TRUE, echo=FALSE, message=FALSE}
knitr::opts_chunk$set(echo=TRUE, warning=FALSE, message=FALSE, cache=FALSE, fig.path=paste0('./Figures_', Sys.Date(), '/')) 
# utility
library(shiny)
library(tibble)
library(data.table)
library(devtools)
library(knitr)
library(tidyr)
library(reshape2)
library(dplyr)
# visualization
library(ggplot2)
library(pander)
library(DT)
library(gridExtra)
library(adegraphics)
library(stats)
#library(ancom.R)
library(smatr)

library(exactRankTests)
library(nlme)
library(compositions)
#git clone from: https://github.com/FrederickHuangLin/ANCOM.git
source("~/ANCOM2.1/ANCOM/scripts/ancom_v2.1.R")
library(ggpubr)

# data analysis

#Need biocondutor (installation method may have changed recently)
#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")

#BiocManager::install("vegan")
library(vegan)
#BiocManager::install("metagenomeSeq")
library(metagenomeSeq)
#BiocManager::install("DESeq2")
library(DESeq2)
#BiocManager::install("biomformat")
library(biomformat)
#BiocManager::install("phyloseq")
library(phyloseq)

sgColorPalette = c("#84CF04","#01B5BB","#E50E63","#6D7272","#8F389E",
                     "#DF8236","#036B6B","#F1BA2F","#9F832D","#94E804",
                     "#01D4DB","#FAC131","#B0B8B8","#F08C3A","#FF106E",
                     "#B948CC","#05B5B5","#CFAA3A")
```

## All parameters
### File paths
```{r filepaths}
##### If you have M3 google drive and bitbucket repo on your local machine, 
##### you only need to change two parameters below
# M3-shared google drive location
#M3folder_loc_for_ps='/Google Drive/M3-shared/V4/Data/200312_ASVdata8_updateAsteria/ps_notnorm_age_filter_complete_family.rds'

# Loading ps using actual filepath for analysis (To change depending on the user)
ps_not_norm_comp <- readRDS("~/M3_Datasets/ps_not_norm_age_filter_complete_family.rds")

## Output data location (subject to change)
#output_data=paste0(M3folder_loc, 'Data/V4/180808_ASVdata4/OutputData_Agefiltered/')
output_data <- "~/M3_Datasets/"

```

### Cutoff parameters
```{r cutoff}
# min post DADA2 counts to run analysis
min_postDD=20000
# DESeq significant cutoff
deseq_cut=0.05
# metagenomeSeq significant cutoff
mtgseq_cut=0.05
# chisquare test cutoff (for diet questionnare results significance)
chisq_cut=0.05
# PERMANOVA pvalue and R2 cutoff for visualization
permanova_pcut=0.05
permanova_cut=0.1
```


# Summarize metadata

```{r sum_meta_fun}
# chisquared test function
run_chisq_test <- function(ps, metacol){
  # ps: phyloseq object
  # metacol: metadata column name to test
  metaDF <- data.frame(sample_data(ps))
  # remove NAs, for some reason, some NA are recorded as a text!
  submetaDF=metaDF[!is.na(metaDF[, metacol]), ]
  submetaDF=submetaDF[submetaDF[, metacol]!='NA', ]
  submetaDF=submetaDF[submetaDF[, metacol]!='', ]   # also remove blank
  # chisquared test
  chisq_res=chisq.test(table(submetaDF[, metacol], submetaDF[, 'phenotype']))
  # extract results
  resDT=data.table(chisq_res$observed)
  # dcast for printing
  resDT <- data.table(dcast(resDT, V1 ~ V2, value.var='N'))
  resDT <- resDT[, testvar:=metacol]
  resDT <- resDT[, chisq_p:=chisq_res$p.value]
  
  return(resDT[, list(testvar, category=V1, A, N, chisq_p)])
}

# composition plot function
plot_composition <- function(chisq_resDT, var_name){
  # chisq_resDT: 4 columns. testvar, category, A, N, chisq_p
  plotDT=melt(chisq_resDT, id.vars=c('testvar', 'category', 'chisq_p'))
  p=ggplot(data=plotDT[testvar==var_name], aes(x=variable, y=value, fill=category))+
    geom_bar(stat="identity")+
    xlab('')+ylab('Number of sample')+
    ggtitle(var_name)+
    theme_minimal()+
    theme(legend.title=element_blank(), legend.position="bottom", axis.text.x=element_text(vjust=1, hjust=1))+
    scale_fill_manual(values=sgColorPalette)
  print(p)
}
```


## Demographics

## fix metadata and remove samples that are too young or have diagnostic discrepancies
```{r fix}
#Remove Breastfed and their families
breast_fed <- c("089_A","054_N", "158_N" )

b_fed<-unique(ps_not_norm_comp@sam_data$Family.group.ID[which(ps_not_norm_comp@sam_data$Host.Name %in% breast_fed)])

#remove the whole family
for (i in b_fed){
  ps_not_norm_comp<- prune_samples(ps_not_norm_comp@sam_data$Family.group.ID != i, ps_not_norm_comp)

}

#fixing the mapping file for stats by adding categorical vs non catergorical
metadata_ok<-sample_data(ps_not_norm_comp)
write.csv(metadata_ok, "sam_data.csv")
map<-read.csv("sam_data.csv")
meta_cat <- read.csv("updated_metacategories.csv")
for (i in meta_cat$varname.16S.V4[which(meta_cat$permanova != FALSE)]){
 if (meta_cat$permanova[which(meta_cat$varname.16S.V4 == i)] == "Categorical") {
    map[,i] <- as.factor(map[,i])
 } else {
    map[,i] <- as.numeric(map[,i])
 }
}


makeFieldsNumeric <- function(map){
  handleNAs <- function(vec){
    vec[vec == ""] <- "NA"
    vec[is.na(vec)] <- "NA"
    return(vec)
  }
  
  map$Stool.frequency <- handleNAs(as.character(map$Stool.frequency))
  map$Stool.frequency[as.character(map$Stool.frequency) == "Less than 1"] = 0
  map$Stool.frequency[as.character(map$Stool.frequency) == "5 or more"] = 5
  map$Dairy..consumption.frequency...longitudinal.[map$Dairy..consumption.frequency...longitudinal. == 5] <- "3-4 meals per week"
  #map$LR2[map$LR2 == "1 (ASD)"] = 1
  #map$LR2[map$LR2 == "0 (non-ASD"] = 0
  
  
  freq_dict_2 <- list("Never" = 0, "Rarely" = 1, "Occasionally" = 2, "Regularly" = 3, "Weekly" = 4, "weekly" = 4,
                      "Several time weekly" = 5, "Several times weekly" = 5, "Daily" = 6, "NA" = NA)
  dict_2_items <- c("Whole.grain..consumption.frequency.", "Fermented.vegetable..consumption.frequency.", "Dairy..consumption.frequency.",                     "Fruit..consumption.frequency.", "Meals.prepared.at.home..consumption.frequency.",   "Ready.to.eat.meals..consumption.frequency.", "Red.meat..consumption.frequency.", "Olive.oil.used.in.cooking..M3.", "Seafood..consumption.frequency.",   "Sweetened.drink..consumption.frequency.", "Vegetable..consumption.frequency.",
                    "Restaurant.prepared.meals..consumption.frequency.", "Sugary.food..consumption.frequency.", "Probiotic..consumption.frequency.", "Vitamin.B.complex.supplement..consumption.frequency.", "Vitamin.D..consumption.frequency.")
  for(item in dict_2_items){
    print(item)
    tmp <- rep(NA, nrow(map))
    freqs <- handleNAs(map[,item])
    numeric_rep <- unlist(freq_dict_2[freqs])
    print(paste("Numeric rep length: ", length(numeric_rep)))
    print(sum(!is.na(freqs)))
    tmp[!is.na(freqs)] <- as.numeric(numeric_rep)  
    map[ , item] <- tmp
  }
  
  
  freq_dict_1 <- list("Never or less than once per week" = 0, "3-4 meals per week" = 1, "5" = 2, "7-10 meals per week" = 3, "Almost every meal" = 4, "NA" = NA)
  dict_1_items <- c("Starchy.food..consumption.frequency...longitudinal.", "Meats.and.seafood..consumption.frequency...longitudinal.", "Bread..consumption.frequency...longitudinal.", "Dairy..consumption.frequency...longitudinal.", "Dietary.fat.and.oil..consumption.frequency...longitudinal.", "Vegetable..consumption.frequency...longitudinal.", 
                    "Fruit..consumption.frequency...longitudinal.")
  for(item in dict_1_items){
    print(item)
    tmp <- rep(NA, nrow(map))
    freqs <- handleNAs(map[ , item])
    numeric_rep <- unlist(freq_dict_1[freqs])
    print(paste("Numeric rep length: ", length(numeric_rep)))
    print(sum(!is.na(freqs)))
    tmp[!is.na(freqs)] <- as.numeric(numeric_rep)  
    map[ , item] <- tmp
  }
  
  #may add more, but these variable only apply to phenotype for autism
    freq_dict_2 <- list("Able to speak fluently" = 3,"Phrase speech"=2, "Single word speech"=1, "Little to no speech" = 0, "Able to have conversation" = 3, "Limited conversation ability" = 2, "Difficulty with conversation" = 1, "Cannot have a conversation" = 0,"Understands about half of words" = 1, "Understands few or no words"= 0, "Understands many words" = 2,  "Understands most words"= 3, "Understands nearly all words" = 4 ,"NA" = NA)
  dict_2_items <- c("Language.ability.and.use", "Conversation.ability", "Understands.speech")
  for(item in dict_2_items){
    print(item)
    tmp <- rep(NA, nrow(map))
    freqs <- handleNAs(map[ , item])
    numeric_rep <- unlist(freq_dict_2[freqs])
    print(paste("Numeric rep length: ", length(numeric_rep)))
    print(sum(!is.na(freqs)))
    tmp[!is.na(freqs)] <- as.numeric(numeric_rep)  
    map[ , item] <- tmp
  }
  
  
  map <- map[!duplicated(map$Biospecimen.Barcode), ]
  rownames(map) <- map$Biospecimen.Barcode
  map$Stool.frequency <- as.numeric(map$Stool.frequency)
  return(map)

}

dict_1_items <- c("Starchy.food..consumption.frequency...longitudinal.", "Meats.and.seafood..consumption.frequency...longitudinal.", "Bread..consumption.frequency...longitudinal.", "Dairy..consumption.frequency...longitudinal.", "Dietary.fat.and.oil..consumption.frequency...longitudinal.", "Vegetable..consumption.frequency...longitudinal.", 
                    "Fruit..consumption.frequency...longitudinal.")
dict_2_items <- c("Language.ability.and.use", "Conversation.ability", "Understands.speech")


map<-makeFieldsNumeric(map)


map_levels<-sapply(map, levels)
map_levelscount<-sapply(map_levels, length)
mapnotfac <- names(map_levelscount[which(map_levelscount >= 18)])

for (i in mapnotfac){
  map[,i]<-as.character(map[,i])
}

map$Age..years. <-round(map$Age..years.)
sample_data(ps_not_norm_comp) <- map

#remove samples that are too young and their paired sibling
tooyoung <-ps_not_norm_comp@sam_data$Family.group.ID[which(ps_not_norm_comp@sam_data$Age..months. < 24)]

#family 65 should be removed according to >24 months criteria
ps_not_norm_comp<- prune_samples(ps_not_norm_comp@sam_data$Family.group.ID != unique(tooyoung), ps_not_norm_comp)

#List of individuals that were reported w/ autism, but was not classified as such through MARA and/or video classifier
pheno_contrad <-read.csv("phenotype_contradictions.csv")
contradicting<-unique(ps_not_norm_comp@sam_data$Family.group.ID[which(ps_not_norm_comp@sam_data$Host.Name %in% as.character(pheno_contrad$host_name))])

#remove the whole family
for (i in contradicting){
  ps_not_norm_comp<- prune_samples(ps_not_norm_comp@sam_data$Family.group.ID != i, ps_not_norm_comp)

}

#round off year
ps_not_norm_comp@sam_data$Age..years.<-round(ps_not_norm_comp@sam_data$Age..years.)

metadata_ok<-ps_not_norm_comp@sam_data



```

### Biological.sex
```{r sex, fig.width=5, fig.height=4}

#now let's only run the categorical values for chi square and remove the first column which are not metadata 
num_cat<-names(Filter(is.numeric, metadata_ok))
fac_cat<-names(Filter(is.factor, metadata_ok))
#removing the first 13 columns, since it's not metadata and the last one which is phenotype  
fac_cat<-fac_cat[-c(1:13, length(fac_cat))]
#finally remiving the ones that were only asked for the children with ASD, or only have one factor & NA, or only present in one phen
fac_cat<-fac_cat[-which(fac_cat %in% c("Behavior.video.submitted..M3.","Language.ability.and.use","Conversation.ability","Understands.speech","Plays.imaginatively.when.alone","Plays.imaginatively.with.others","Plays.in.a.group.with.others","Eye.contact.finding","Childhood.behavioral.development.finding","Repetitive.motion","Picks.up.objects.to.show.to.others","Sleep.pattern.finding","Response.to.typical.sounds","Self.injurious.behavior.finding","Gastrointestinal.problems..M3.", "Imitation.behavior", "Other.stool.sample.collection.method.explained..M3.", "Flu.shot.in.the.last..MFlu.shot.in.the.last..M3.", "Pica.disease", "Additional.info.affecting.microbiome..M3.", "Dietary.restrictions.details..M3.", "Pet.bird"))]



#Also remove the ones with only one factor (no chi-square possible)
#now running the chisquare on all categorical values 
chisquare_p.val=c()
names_chisquare_p.val=c()
all_chisquare=list()
chi_list<-names(map_levelscount)[map_levelscount > 1]
chi_list <-chi_list[-c(1:9)]
chi_list<-chi_list[-which(chi_list %in% c("Behavior.video.submitted..M3.","Language.ability.and.use","Conversation.ability","Understands.speech","Plays.imaginatively.when.alone","Plays.imaginatively.with.others","Plays.in.a.group.with.others","Eye.contact.finding","Childhood.behavioral.development.finding","Repetitive.motion","Picks.up.objects.to.show.to.others","Sleep.pattern.finding","Response.to.typical.sounds","Self.injurious.behavior.finding","Gastrointestinal.problems..M3.", "Imitation.behavior", "Other.stool.sample.collection.method.explained..M3.", "Flu.shot.in.the.last..MFlu.shot.in.the.last..M3.", "Pica.disease", "Additional.info.affecting.microbiome..M3.", "Dietary.restrictions.details..M3.", "Pet.bird", "Host.disease.status", "phenotype"))]

map_num<-sapply(map, is.numeric)
num_cat <- colnames(map[,as.vector(which(map_num == TRUE))])
num_cat <- num_cat[-c(1:4)]
num_cat <- num_cat[-which(num_cat %in% c("Language.ability.and.use", "Conversation.ability", "Understands.speech", "Mobile.Autism.Risk.Assessment.Score", "Number.of.small.pet.herbivores", "Number.of.small.pet.rodents", "phenotype_num", "Number.of.pet.birds"))]

chi_list <- c(chi_list, num_cat)

for (i in 1:length(chi_list)){
    tmp<-run_chisq_test(ps_not_norm_comp, chi_list[i])
    chisquare_p.val<-c(chisquare_p.val,min(tmp$chisq_p))
    names_chisquare_p.val<-c(names_chisquare_p.val,chi_list[i])
    all_chisquare[[i]]<-tmp
}
names(chisquare_p.val)<-names_chisquare_p.val
names(all_chisquare) <-chi_list

# p-value correction
chisquare_p.val<-p.adjust(chisquare_p.val)
chisquare_p.val<-chisquare_p.val[chisquare_p.val < 0.05]

length(chisquare_p.val) #41

chisquare_p.val

#vizualisation of the results 
#select only the signififcant ones
all_chisquare<-all_chisquare[names(all_chisquare) %in% names(chisquare_p.val)]
#save this into a csv
write.csv(format(chisquare_p.val, digits=2), file=paste0(output_data,"Xsqr_05.csv"), quote=F)
# plot one example out of 29 
plot_composition(all_chisquare[1], names(all_chisquare)[1])

```



### Racial.group
```{r race, fig.width=5, fig.height=4}
# print number table
table(sample_data(ps_not_norm_comp)$Racial.group, sample_data(ps_not_norm_comp)$Biological.sex)
# run chisquared test
race=run_chisq_test(ps_not_norm_comp, 'Racial.group')
# print results
pander(race)
# plot
plot_composition(race, 'Racial.group')
# % table
race_prop=prop.table(as.matrix(race[, .(A, N)]), margin=2)*100
row.names(race_prop) <- race$category
pander(race_prop)

# write
write.csv(race_prop, file=paste0(output_data, 'Race.csv'))
```

### Age..months.
```{r age, fig.width=5, fig.height=4}
# make sure it is numeric
sample_data(ps_not_norm_comp)$Age..months. <- as.numeric(sample_data(ps_not_norm_comp)$Age..months.)

# plot
ggplot(data=sample_data(ps_not_norm_comp), aes(x=phenotype, y=Age..months., fill=phenotype))+
  geom_boxplot(width=0.7, outlier.colour='white')+
  geom_jitter(size=1, position=position_jitter(width=0.1))+
  xlab('')+ylab('Age (months)')+
  scale_fill_manual(values=sgColorPalette)+
  theme_minimal()

# run tests to check significance
shapiro.test(sample_data(ps_not_norm_comp)$Age..months.) #not normal we need a reanking test
wilcox.test(Age..months. ~ phenotype, data=data.frame(sample_data(ps_not_norm_comp)), var.equal=FALSE)

#Let's generalized all the values with numeric input
wilcox_pval=c()

for (i in 1:length(num_cat)){
  #if (levels(get(num_cat[i], metadata_ok)) >= 2)
  tmp<-wilcox.test(get(num_cat[i]) ~ phenotype, data=map, var.equal=FALSE)
  wilcox_pval<-c(wilcox_pval,tmp$p.value)
}
names(wilcox_pval)<-num_cat
#correction 
wilcox_pval<-p.adjust(wilcox_pval)
wilcox_pval[wilcox_pval<0.05]  #LRprobabilities , Veget, bread, dairy fruit, sweet drink

```

## Dietary variance
Dietary variance amongst ASD patients will also be assessed. Based on preliminary analyses, we expect that ASD participants, collectively, will exhibit a minimal degree of dietary variance.
```{r diet_summary, fig.width=5, fig.height=4}
# read metadata category file
#meta_cat=fread(paste0(M3folder_loc, meta_cat_fp), header=TRUE)

#Created this csv from the file in the shared M3 google drive, took the first sheet and removed the last incomplete column, then converted to csv
meta_cat<-read.csv("updated_metacategories.csv")
colnames(meta_cat)[1] <- "varname"

# list of diet questions
diet_info<-metadata_ok[,colnames(metadata_ok) %in% meta_cat$varname[which(meta_cat$diet==TRUE)]]
#additionnal error to remove: filled with only NA or one factor, cant do chisquare on one factor
diet_col_levels<-sapply(diet_info, levels)
dietcol_levelscount<-sapply(diet_col_levels, length)

#Since there numerics dietary variables are only two and filled primarily with NAs (as shown by line 248, we will omit)
#diet_info[,which(sapply(diet_info, class) == "numeric")]
diet_info <- diet_info[,which(dietcol_levelscount >= 2)]

#dietq_col <-which(colnames(sample_data(ps_not_norm_comp)) %in% colnames(diet_info))
dietq_col <- colnames(diet_info)

# for each variable, summarize and check if A vs N different? (we hypothesized variance in ASD are the same as NT?)
master_resDT=NULL
for(i in dietq_col){
  resDT=run_chisq_test(ps_not_norm_comp, i)
# add to master
  master_resDT <- rbindlist(list(master_resDT, resDT))
}

# variables tested
unique(master_resDT$testvar)

# order by significance
master_resDT <- master_resDT[order(chisq_p)]

# print table
datatable(master_resDT)

# write csv file
write.csv(master_resDT, file=paste0(output_data, 'Dietary_var_all_proportion.csv'))
write.csv(unique(master_resDT[, list(testvar, chisq_p)]), file=paste0(output_data, 'Dietary_var_chisq_test.csv'))

# plot top 3 most significant vars
plot_diet=master_resDT[testvar %in% unique(master_resDT[, list(testvar, chisq_p)])$testvar[1:3]]
for(i in unique(plot_diet$testvar)){
  plot_composition(plot_diet, i)
}

```


# Normalization
```{r normalization}
dir.create(paste0(output_data, 'Normalized/'))

#Filtering of the prevalence: 
###Declare function to filter
filterTaxaByPrevolence <- function(ps, percentSamplesPresentIn){
  prevalenceThreshold <- percentSamplesPresentIn * nsamples(ps)
  toKeep <- apply(data.frame(otu_table(ps)), 1, function(taxa) return(sum(taxa > 0) > prevalenceThreshold))
  ps_filt <- prune_taxa(toKeep, ps)
  return(ps_filt)
}

#CSS norm function
#We actually will plot everything with CSS 
CSS_norm<-function(ps){
  ps.metaG<-phyloseq_to_metagenomeSeq(ps)
  p_stat = cumNormStatFast(ps.metaG)
  ps.metaG = cumNorm(ps.metaG, p = p_stat)
  ps.metaG.norm <- MRcounts(ps.metaG, norm = T)
  ps_CSS<-phyloseq(otu_table(ps.metaG.norm, taxa_are_rows = T), sample_data(ps),tax_table(ps))
  return(ps_CSS)
}

#Deseq norm 
deSeqNorm <- function(ps){
ps_dds <- phyloseq_to_deseq2(ps, ~ phenotype)
ps_dds <- estimateSizeFactors(ps_dds, type = "poscounts")
ps_dds <- estimateDispersions(ps_dds)
abund <- getVarianceStabilizedData(ps_dds)
abund <- abund + abs(min(abund)) #don't allow deseq to return negative counts
ps_deSeq <- phyloseq(otu_table(abund, taxa_are_rows = T), sample_data(ps), tax_table(ps))
return(ps_deSeq)
}

#Now we remove the taxa present in less than 3 % of the samples with some basic filtering 
filtered_ps003<-filterTaxaByPrevolence(ps_not_norm_comp, 0.03)
filtered_ps003
saveRDS(filtered_ps003, file=paste0(output_data, "Normalized/ps_not_norm_comp_pass_min_postDD_min0.03.Rda"))

# CSS normalization
ps_CSS_norm_pass_min_postDD_sup003<-CSS_norm(filtered_ps003)
saveRDS(ps_CSS_norm_pass_min_postDD_sup003, file=paste0(output_data, "Normalized/ps_CSS_pass_min_postDD_min0.03.Rda"))

# DESeq normalization
ps_DeSeq_norm_pass_min_postDD_sup003<-deSeqNorm(filtered_ps003)
saveRDS(ps_DeSeq_norm_pass_min_postDD_sup003, file=paste0(output_data, "Normalized/ps_DeSeq_pass_min_postDD_min0.03.Rda"))

# TSS normalization
propDF=prop.table(as.matrix(otu_table(filtered_ps003)), margin=2)
ps_TSS_norm_pass_min_postDD_sup003 <- phyloseq(otu_table(propDF, taxa_are_rows=TRUE), 
                                               tax_table(filtered_ps003), 
                                               sample_data(filtered_ps003))
```


### Repeated measures ANOVA to find ASVs that have means that change significantly between timepoints
```{r ANOVA}
#format asv table with timepoint + hostname info
asv_table<-t(otu_table(ps_DeSeq_norm_pass_min_postDD_sup003))
asv_table <- as.data.frame(asv_table)
asv_table$timepoint <- ps_DeSeq_norm_pass_min_postDD_sup003@sam_data$Within.study.sampling.date
asv_table$timepoint <- as.factor(asv_table$timepoint)
asv_table$Host.Name <- ps_DeSeq_norm_pass_min_postDD_sup003@sam_data$Host.Name

#Create initial table of first asv to build off of
tmp <-summary(aov(asv_table[,1] ~ timepoint + Error(Host.Name/timepoint), data = asv_table))  
p_val <-tmp$`Error: Host.Name:timepoint`[[1]]$`Pr(>F)`[1]
anova_asv_res <- tibble(colnames(asv_table[1]), p_val)
colnames(anova_asv_res) <- c("ASV", "p_val")

#Run for each asv
for (i in 2:(length(colnames(asv_table))-2)) {
  form <-as.formula(paste0("asv_table[," , i, "]", " ~ timepoint + Error(Host.Name/timepoint)"))
  tmp <-summary(aov(formula = form, data = asv_table))  
  p_val <-tmp$`Error: Host.Name:timepoint`[[1]]$`Pr(>F)`[1]
  tmpres <- tibble(colnames(asv_table[i]), p_val)
  colnames(tmpres) <- c("ASV", "p_val")
  anova_asv_res<- rbind(anova_asv_res, tmpres)
}

#find sig ones btwn timepoints
asv_sig_btwn_timep_DES<-anova_asv_res$ASV[which(anova_asv_res$p_val <= 0.05)]

asv_sig_btwn_timep_DES


#format asv table with timepoint + hostname info (CSS now)
asv_table<-t(otu_table(ps_CSS_norm_pass_min_postDD_sup003))
asv_table <- as.data.frame(asv_table)
asv_table$timepoint <- ps_DeSeq_norm_pass_min_postDD_sup003@sam_data$Within.study.sampling.date
asv_table$timepoint <- as.factor(asv_table$timepoint)
asv_table$Host.Name <- ps_DeSeq_norm_pass_min_postDD_sup003@sam_data$Host.Name

#Create initial table of first asv to build off of
tmp <-summary(aov(asv_table[,1] ~ timepoint + Error(Host.Name/timepoint), data = asv_table))  
p_val <-tmp$`Error: Host.Name:timepoint`[[1]]$`Pr(>F)`[1]
anova_asv_res <- tibble(colnames(asv_table[1]), p_val)
colnames(anova_asv_res) <- c("ASV", "p_val")

#Run for each asv
for (i in 2:(length(colnames(asv_table))-2)) {
  form <-as.formula(paste0("asv_table[," , i, "]", " ~ timepoint + Error(Host.Name/timepoint)"))
  tmp <-summary(aov(formula = form, data = asv_table))  
  p_val <-tmp$`Error: Host.Name:timepoint`[[1]]$`Pr(>F)`[1]
  tmpres <- tibble(colnames(asv_table[i]), p_val)
  colnames(tmpres) <- c("ASV", "p_val")
  anova_asv_res<- rbind(anova_asv_res, tmpres)
}

#find sig ones btwn timepoints
asv_sig_btwn_timep_CSS<-anova_asv_res$ASV[which(anova_asv_res$p_val <= 0.05)]

asv_sig_btwn_timep_CSS

#7 in common
asv_sig_btwn_timep_DES[asv_sig_btwn_timep_DES %in% asv_sig_btwn_timep_CSS]

#remove these taxa from phyloseqs (since they are noise essentially)
filtered_ps003 <-prune_taxa(filtered_ps003, taxa = taxa_names(filtered_ps003)[!(taxa_names(filtered_ps003) %in% asv_sig_btwn_timep_DES)])

ps_CSS_norm_pass_min_postDD_sup003<- prune_taxa(ps_CSS_norm_pass_min_postDD_sup003, taxa = taxa_names(ps_CSS_norm_pass_min_postDD_sup003)[!(taxa_names(ps_CSS_norm_pass_min_postDD_sup003) %in% asv_sig_btwn_timep_CSS)])

ps_DeSeq_norm_pass_min_postDD_sup003<- prune_taxa(ps_DeSeq_norm_pass_min_postDD_sup003, taxa = taxa_names(ps_DeSeq_norm_pass_min_postDD_sup003)[!(taxa_names(ps_DeSeq_norm_pass_min_postDD_sup003) %in% asv_sig_btwn_timep_DES)])


```

# DA taxa identification
Identify bacterial and archaeal taxa (genera, species and strains) whose abundance is observed significantly more or less in the ASD

## DESeq
```{r deseq_test}
dir.create(paste0(output_data, 'DESeq/'))
###Run DESeq proper (not the normalization but all of it)
runDESeq <- function(ps, dcut){
  diagdds = phyloseq_to_deseq2(ps, ~ phenotype) 
  diagdds <- estimateSizeFactors(diagdds, type = "poscounts")
  diagdds <- DESeq(diagdds,fitType="parametric", betaPrior = FALSE) 
  res = results(diagdds, contrast = c("phenotype", "N", "A"))
  res$padj[is.na(res$padj)] = 1
  sig <- res[res$padj < dcut,]
  if (dim(sig)[1] == 0) 
  {sigtab<- as.data.frame(1, row.names="nothing")
    colnames(sigtab) <- 'padj'}
    else 
    {
      sigtab <- data.frame(sig)
      }
  return(list(res, sigtab))
}


###Running analysis 
###split thedata based on the real 3 timepoints
P1<-prune_samples(rownames(sample_data(filtered_ps003))[sample_data(filtered_ps003)$Within.study.sampling.date == "Timepoint 1"], filtered_ps003)
P2<-prune_samples(rownames(sample_data(filtered_ps003))[sample_data(filtered_ps003)$Within.study.sampling.date == "Timepoint 2"], filtered_ps003)
P3<-prune_samples(rownames(sample_data(filtered_ps003))[sample_data(filtered_ps003)$Within.study.sampling.date == "Timepoint 3"], filtered_ps003)

#several significants 
deseq_res_P1 <- runDESeq(P1, deseq_cut) 
deseq_res_P2 <- runDESeq(P2, deseq_cut)
deseq_res_P3 <- runDESeq(P3, deseq_cut)

# print significant taxa
datatable(deseq_res_P1[[2]])
datatable(deseq_res_P2[[2]])
datatable(deseq_res_P3[[2]])
#"ASV_1669" present twice timepoint 1 and 3 

# save
saveRDS(deseq_res_P1, file=paste0(output_data, "DESeq/deseq_res_P1_adjp", deseq_cut, ".Rda"))
saveRDS(deseq_res_P2, file=paste0(output_data, "DESeq/deseq_res_P2_adjp", deseq_cut, ".Rda"))
saveRDS(deseq_res_P3, file=paste0(output_data, "DESeq/deseq_res_P3_adjp", deseq_cut, ".Rda"))

#Working with time series
#according to the DeSeq vignette: design including the time factor, and then test using the likelihood ratio test as described
#the following section, where the time factor is removed in the reduced formula
runDESeq_time <- function(ps, dcut){
  diagdds = phyloseq_to_deseq2(ps, ~ phenotype + Within.study.sampling.date) 
  diagdds <- estimateSizeFactors(diagdds, type = "poscounts")
  diagdds <- DESeq(diagdds,fitType="parametric", betaPrior = FALSE) 
  #resultsNames(diagdds): to determine the constrast
  res = results(diagdds, contrast = c("phenotype", "A", "N"))
  res$padj[is.na(res$padj)] = 1
  sig <- res[res$padj < dcut,]
  if (dim(sig)[1] == 0) 
  {sigtab<- as.data.frame(1, row.names="nothing")
  colnames(sigtab) <- 'padj'}
  else 
  {
    sigtab <- data.frame(sig)
  }
  return(list(res, sigtab))
}

#and this time when factoring in the interaction for longitudinal study! 
bla<-runDESeq_time(filtered_ps003, deseq_cut)
saveRDS(bla, file=paste0(output_data, "DESeq/Deseq_time_interaction_adjp", deseq_cut, ".Rda"))

datatable(bla[2][[1]])

# significant ASVs
row.names(bla[2][[1]])
des_res<-cbind(row.names(bla[2][[1]]), as(tax_table(filtered_ps003)[row.names(bla[2][[1]]), ], "matrix"))
des_res_esv <- des_res
rownames(des_res) <- NULL
des_res

```

## metagenomeSeq
```{r metagenomeseq_test}
dir.create(paste0(output_data, 'metagenomseq/'))
###Run ZIG model fitting and prediction
run_metagenom_seq<-function(ps,maxit, mcut){
  p_metag<-phyloseq_to_metagenomeSeq(ps)
  #filtering at least 4 samples 
  p_metag= cumNorm(p_metag, p=0.75)
  normFactor =normFactors(p_metag)
  normFactor =log2(normFactor/median(normFactor) + 1)
  #mod = model.matrix(~ASDorNeuroT +PairASD+ normFactor)
  mod = model.matrix(~phenotype + normFactor, data = pData(p_metag))
  settings =zigControl(maxit =maxit, verbose =FALSE)
  #settings =zigControl(tol = 1e-5, maxit = 30, verbose = TRUE, pvalMethod = 'bootstrap')
  fit =fitZig(obj = p_metag, mod = mod, useCSSoffset = FALSE, control = settings)
  #Note: changed fit$taxa to fit@taxa in light of error (probably from newer metagenomeseq ver.)
  res_fit<-MRtable(fit, number = length(fit@taxa))
  res_fit_nonfiltered <- copy(res_fit)
  res_fit<-res_fit[res_fit$adjPvalues<mcut,]
  #finally remove the ones that are not with enough samples
  #mean_sample<-mean(calculateEffectiveSamples(fit))
  #res_fit<-res_fit[res_fit$`counts in group 0` & res_fit$`counts in group 1` > mean_sample,]
  Min_effec_samp<-calculateEffectiveSamples(fit)
  Min_effec_samp<-Min_effec_samp[ names(Min_effec_samp)  %in% rownames(res_fit)] #####there is a bug here 
  #manually removing the ones with "NA"
  res_fit<-res_fit[grep("NA",rownames(res_fit), inv=T),]
  res_fit$Min_sample<-Min_effec_samp
  res_fit<-res_fit[res_fit$`+samples in group 0` >= Min_effec_samp & res_fit$`+samples in group 1` >= Min_effec_samp,]
  return(list(res_fit_nonfiltered, res_fit))
}

run_metagenom_seq2<-function(ps,maxit, mcut){
  p_metag<-phyloseq_to_metagenomeSeq(ps)
  #filtering at least 4 samples 
  p_metag= cumNorm(p_metag, p=0.75)
  normFactor =normFactors(p_metag)
  normFactor =log2(normFactor/median(normFactor) + 1)
  #mod = model.matrix(~ASDorNeuroT +PairASD+ normFactor)
  mod = model.matrix(~phenotype + Within.study.sampling.date +normFactor, data = pData(p_metag))
  settings =zigControl(maxit =maxit, verbose =FALSE)
  #settings =zigControl(tol = 1e-5, maxit = 30, verbose = TRUE, pvalMethod = 'bootstrap')
  fit =fitZig(obj = p_metag, mod = mod, useCSSoffset = FALSE, control = settings)
  #Note: changed fit$taxa to fit@taxa in light of error (probably from newer metagenomeseq ver.)
  res_fit<-MRtable(fit, number = length(fit@taxa))
  res_fit_nonfiltered <- copy(res_fit)
  res_fit<-res_fit[res_fit$adjPvalues<mcut,]
  #finally remove the ones that are not with enough samples
  #mean_sample<-mean(calculateEffectiveSamples(fit))
  #res_fit<-res_fit[res_fit$`counts in group 0` & res_fit$`counts in group 1` > mean_sample,]
  Min_effec_samp<-calculateEffectiveSamples(fit)
  Min_effec_samp<-Min_effec_samp[ names(Min_effec_samp)  %in% rownames(res_fit)] #####there is a bug here 
  #manually removing the ones with "NA"
  res_fit<-res_fit[grep("NA",rownames(res_fit), inv=T),]
  res_fit$Min_sample<-Min_effec_samp
  res_fit<-res_fit[res_fit$`+samples in group 0` >= Min_effec_samp & res_fit$`+samples in group 1` >= Min_effec_samp,]
  return(list(res_fit_nonfiltered, res_fit))
}

#Now for each time
P1<-prune_samples(rownames(sample_data(filtered_ps003))[sample_data(filtered_ps003)$Within.study.sampling.date == "Timepoint 1"], filtered_ps003)
P2<-prune_samples(rownames(sample_data(filtered_ps003))[sample_data(filtered_ps003)$Within.study.sampling.date == "Timepoint 2"], filtered_ps003)
P3<-prune_samples(rownames(sample_data(filtered_ps003))[sample_data(filtered_ps003)$Within.study.sampling.date == "Timepoint 3"], filtered_ps003)

zig_res_P1 <- run_metagenom_seq(P1,30, mtgseq_cut) # 30The maximum number of iterations for the expectation-maximization algorithm
zig_res_P2 <- run_metagenom_seq(P2,30, mtgseq_cut)
zig_res_P3 <- run_metagenom_seq(P3,30, mtgseq_cut)

zig_res_all<- run_metagenom_seq2(filtered_ps003,30, mtgseq_cut)

# print significant taxa
datatable(zig_res_P1[[2]])
datatable(zig_res_P2[[2]])
datatable(zig_res_P3[[2]])
datatable(zig_res_all[[2]])

zig_res_P1_filtered <- data.frame(cbind(zig_res_P1[[2]], tax_table(P1)[rownames(zig_res_P1[[2]]),]))
zig_res_P1_filtered$enriched <- ifelse(zig_res_P1_filtered$phenotypeN < 0, "Aut", "Control")

zig_res_P2_filtered <- data.frame(cbind(zig_res_P2[[2]], tax_table(P2)[rownames(zig_res_P2[[2]]), ]))
zig_res_P2_filtered$enriched <- ifelse(zig_res_P2_filtered$phenotypeN < 0, "Aut", "Control")

zig_res_P3_filtered <- data.frame(cbind(zig_res_P3[[2]], tax_table(P3)[rownames(zig_res_P3[[2]]), ]))
zig_res_P3_filtered$enriched <- ifelse(zig_res_P3_filtered$phenotypeN < 0, "Aut", "Control")

zig_res_all_filtered <- data.frame(cbind(zig_res_all[[2]], tax_table(filtered_ps003)[rownames(zig_res_all[[2]]), ]))
zig_res_all_filtered$enriched <- ifelse(zig_res_all_filtered$phenotypeN < 0, "Aut", "Control")


saveRDS(zig_res_P1, file=paste0(output_data, "metagenomseq/zig_res_P1_adjp", mtgseq_cut, ".rds"))
saveRDS(zig_res_P2, file=paste0(output_data, "metagenomseq/zig_res_P2_adjp", mtgseq_cut, ".rds"))
saveRDS(zig_res_P3, file=paste0(output_data, "metagenomseq/zig_res_P3_adjp", mtgseq_cut, ".rds"))

#do we have any in ESV in common?
#Reduce(intersect, list(rownames(zig_res_P1_filtered),rownames(zig_res_P2_filtered),rownames(zig_res_P3_filtered)))
#rownames(zig_res_P1[[2]])[which(rownames(zig_res_P1[[2]]) %in% c(rownames(zig_res_P2[[2]]), rownames(zig_res_P3[[2]])))]
#rownames(zig_res_P2[[2]])[which(rownames(zig_res_P2[[2]]) %in% rownames(zig_res_P3[[2]]))]

metag_res<-cbind(rownames(zig_res_all[[2]]), as(tax_table(filtered_ps003)[rownames(zig_res_all[[2]]), ], "matrix"))
metag_res_esv <-metag_res
rownames(metag_res) <- NULL
metag_res

```

## ANCOM
```{r ancom}
#ANCOM_old ver (2.1 can be seen after)
#retrive taxa
#format metadata
#metada_ps<-sample_data(filtered_ps003)
#metada_ps<-as.data.frame(metada_ps)
#res_table_filt<-otu_table(filtered_ps003)
#res_table_filt<-as.data.frame(res_table_filt)
#res_table_filt<-t(res_table_filt)
#res_table_filt<-as.data.frame(res_table_filt)

#res_table_filt$metada<-metada_ps$phenotype[rownames(metada_ps)%in%rownames(res_table_filt)]
#ancom.all.filt.0.05 <- ANCOM(res_table_filt, sig = 0.05, multcorr = 2)
#saveRDS(ancom.all.filt.0.05, file=paste0(output_data, "ANCOM/ancom_res", mtgseq_cut, ".rds"))

#Format the Detected Table w/ Taxa 
#main.05 <- cbind(ancom.all.filt.0.05$detected, as(tax_table(filtered_ps003)[ancom.all.filt.0.05$detected, ], "matrix"))

#main.05esv <- main.05
#row.names(main.05) <- NULL
#main.05



#New ANCOM 2.1

#retrive taxa
#format metadata
metada_ps<-sample_data(filtered_ps003)
metada_ps<-as.data.frame(metada_ps)
metada_ps$HostName <- as.character(metada_ps$Host.Name)
metada_ps$phenotype <- as.character(metada_ps$phenotype)

metada_ps<-tibble(metada_ps$HostName, metada_ps$phenotype, rows = rownames(metada_ps))
colnames(metada_ps) <- c("HostName", "phenotype", "Biospecimen.Barcode")
res_table_filt<-otu_table(filtered_ps003)
res_table_filt<-as.data.frame(res_table_filt)

prepro<-feature_table_pre_process(feature_table = res_table_filt, meta_data = metada_ps, sample_var = "Biospecimen.Barcode", group_var = "phenotype", out_cut = 0.05, zero_cut = 0.90, lib_cut = 1000, neg_lb = FALSE)

feature_table = prepro$feature_table # Preprocessed feature table
meta_data = prepro$meta_data # Preprocessed metadata
struc_zero = prepro$structure_zeros # Structural zero info

main_var = "phenotype"; p_adj_method = "BH"; alpha = 0.05
adj_formula = NULL; rand_formula = "~ 1 | HostName" ; control = list(msMaxIter = 50)
ancom.all.filt.0.05 <- ANCOM(feature_table, meta_data, struc_zero, main_var, p_adj_method, 
            alpha, adj_formula, rand_formula)#, control)
dir.create(path = "ANCOM")
saveRDS(ancom.all.filt.0.05, file=paste0(output_data, "ANCOM/ancom_res", mtgseq_cut, ".rds"))

#Format the Detected Table w/ Taxa 
ancom.all.filt.0.05$detected

#no significant taxa from ANCOM

#main.05 <- cbind(ancom.all.filt.0.05$detected, as(tax_table(filtered_ps003)[ancom.all.filt.0.05$detected, ], "matrix"))
#main.05esv <- main.05
#row.names(main.05) <- NULL
#main.05


#Trying by each timepoint
#retrive taxa
#format metadata
ps3<-subset_samples(filtered_ps003, Within.study.sampling.date == "Timepoint 3" )
metada_ps<-sample_data(ps3)
metada_ps<-as.data.frame(metada_ps)
metada_ps$HostName <- as.character(metada_ps$Host.Name)
metada_ps$phenotype <- as.character(metada_ps$phenotype)

metada_ps<-tibble(metada_ps$HostName, metada_ps$phenotype, rows = rownames(metada_ps))
colnames(metada_ps) <- c("HostName", "phenotype", "Biospecimen.Barcode")
res_table_filt<-otu_table(ps3)
res_table_filt<-as.data.frame(res_table_filt)

prepro<-feature_table_pre_process(feature_table = res_table_filt, meta_data = metada_ps, sample_var = "Biospecimen.Barcode", group_var = "phenotype", out_cut = 0.05, zero_cut = 0.90, lib_cut = 1000, neg_lb = FALSE)

feature_table = prepro$feature_table # Preprocessed feature table
meta_data = prepro$meta_data # Preprocessed metadata
struc_zero = prepro$structure_zeros # Structural zero info

main_var = "phenotype"; p_adj_method = "BH"; alpha = 0.05
adj_formula = NULL; rand_formula = NULL
ancom.all.filt.0.05.3 <- ANCOM(feature_table, meta_data, struc_zero, main_var, p_adj_method, 
            alpha, adj_formula, rand_formula)#, control)
#dir.create(path = "ANCOM")
saveRDS(ancom.all.filt.0.05.3, file=paste0(output_data, "ANCOM/ancom_res3_", mtgseq_cut, ".rds"))

#Format the Detected Table w/ Taxa 
ancom.all.filt.0.05.3$detected
# No sig

#format metadata
ps2<-subset_samples(filtered_ps003, Within.study.sampling.date == "Timepoint 2" )
metada_ps<-sample_data(ps2)
metada_ps<-as.data.frame(metada_ps)
metada_ps$HostName <- as.character(metada_ps$Host.Name)
metada_ps$phenotype <- as.character(metada_ps$phenotype)

metada_ps<-tibble(metada_ps$HostName, metada_ps$phenotype, rows = rownames(metada_ps))
colnames(metada_ps) <- c("HostName", "phenotype", "Biospecimen.Barcode")
res_table_filt<-otu_table(ps2)
res_table_filt<-as.data.frame(res_table_filt)

prepro<-feature_table_pre_process(feature_table = res_table_filt, meta_data = metada_ps, sample_var = "Biospecimen.Barcode", group_var = "phenotype", out_cut = 0.05, zero_cut = 0.90, lib_cut = 1000, neg_lb = FALSE)

feature_table = prepro$feature_table # Preprocessed feature table
meta_data = prepro$meta_data # Preprocessed metadata
struc_zero = prepro$structure_zeros # Structural zero info

main_var = "phenotype"; p_adj_method = "BH"; alpha = 0.05
adj_formula = NULL; rand_formula = NULL
ancom.all.filt.0.05.2 <- ANCOM(feature_table, meta_data, struc_zero, main_var, p_adj_method, 
            alpha, adj_formula, rand_formula)#, control)
#dir.create(path = "ANCOM")
saveRDS(ancom.all.filt.0.05.2, file=paste0(output_data, "ANCOM/ancom_res2_", mtgseq_cut, ".rds"))

#Format the Detected Table w/ Taxa 
ancom.all.filt.0.05.2$detected
# No sig

#format metadata
ps1<-subset_samples(filtered_ps003, Within.study.sampling.date == "Timepoint 1" )
metada_ps<-sample_data(ps1)
metada_ps<-as.data.frame(metada_ps)
metada_ps$HostName <- as.character(metada_ps$Host.Name)
metada_ps$phenotype <- as.character(metada_ps$phenotype)

metada_ps<-tibble(metada_ps$HostName, metada_ps$phenotype, rows = rownames(metada_ps))
colnames(metada_ps) <- c("HostName", "phenotype", "Biospecimen.Barcode")
res_table_filt<-otu_table(ps1)
res_table_filt<-as.data.frame(res_table_filt)

prepro<-feature_table_pre_process(feature_table = res_table_filt, meta_data = metada_ps, sample_var = "Biospecimen.Barcode", group_var = "phenotype", out_cut = 0.05, zero_cut = 0.90, lib_cut = 1000, neg_lb = FALSE)

feature_table = prepro$feature_table # Preprocessed feature table
meta_data = prepro$meta_data # Preprocessed metadata
struc_zero = prepro$structure_zeros # Structural zero info

main_var = "phenotype"; p_adj_method = "BH"; alpha = 0.05
adj_formula = NULL; rand_formula = NULL
ancom.all.filt.0.05.1 <- ANCOM(feature_table, meta_data, struc_zero, main_var, p_adj_method, 
            alpha, adj_formula, rand_formula)#, control)
#dir.create(path = "ANCOM")
saveRDS(ancom.all.filt.0.05.1, file=paste0(output_data, "ANCOM/ancom_res1_", mtgseq_cut, ".rds"))

#Format the Detected Table w/ Taxa 
ancom.all.filt.0.05.1$detected
# No sig



```

## Results table summarizing significant taxa

```{r resultstable}
#Deseq results

DesP1<-tibble(rownames(deseq_res_P1[[2]]), rep("DESeq2_P1", length(rownames(deseq_res_P1[[2]]))))
colnames(DesP1) <- c("ASV", "Method+Data")

DesP2<-tibble(rownames(deseq_res_P2[[2]]), rep("DESeq2_P2", length(rownames(deseq_res_P2[[2]]))))
colnames(DesP2) <- c("ASV", "Method+Data")

DesP3<-tibble(rownames(deseq_res_P3[[2]]), rep("DESeq2_P3", length(rownames(deseq_res_P3[[2]]))))
colnames(DesP3) <- c("ASV", "Method+Data")

DesAll<-tibble(des_res[,1], rep("DESeq2_All", length(des_res[,1])))
colnames(DesAll) <- c("ASV", "Method+Data")

deseq_allsig<-rbind(DesP1,DesP2, DesP3, DesAll)

deseqcount<-plyr::ddply(deseq_allsig, "ASV", transform, count = length(ASV))
duplic<-tibble(deseqcount$ASV[which(deseqcount$count == 2)], deseqcount$Method.Data[which(deseqcount$count == 2)])
a<-tibble(duplic$`deseqcount$ASV[which(deseqcount$count == 2)]`[1], "DESeq2_P3+All")
colnames(a) <- c("ASV", "Method+Data")

b<-tibble(duplic$`deseqcount$ASV[which(deseqcount$count == 2)]`[3], "DESeq2_P1+P3")
colnames(b) <- c("ASV", "Method+Data")

to_add_backin<-rbind(a,b)

deseq_allsig<-deseq_allsig[-which(deseq_allsig$ASV == deseqcount$ASV[which(deseqcount$count == 2)][1]),]
deseq_allsig<-deseq_allsig[-which(deseq_allsig$ASV == deseqcount$ASV[which(deseqcount$count == 2)][3]),]

deseq_allsig<-rbind(deseq_allsig, to_add_backin)
deseq_allsig<-cbind(deseq_allsig, as(tax_table(filtered_ps003)[deseq_allsig$ASV, ], "matrix"))
saveRDS(deseq_allsig, "DESeq/full_res_table_deseq")

deseq_allsig.print <- deseq_allsig
deseq_allsig.print$ASV <- NULL
rownames(deseq_allsig.print) <- NULL
deseq_allsig.print

#MTG results

MtgP1<-tibble(rownames(zig_res_P1[[2]]), rep("Mtg_P1", length(rownames(zig_res_P1[[2]]))))
colnames(MtgP1) <- c("ASV", "Method+Data")

MtgP2<-tibble(rownames(zig_res_P2[[2]]), rep("Mtg_P2", length(rownames(zig_res_P2[[2]]))))
colnames(MtgP2) <- c("ASV", "Method+Data")

MtgP3<-tibble(rownames(zig_res_P3[[2]]), rep("Mtg_P3", length(rownames(zig_res_P3[[2]]))))
colnames(MtgP3) <- c("ASV", "Method+Data")

MtgAll<-tibble(metag_res[,1], rep("Mtg_All", length(metag_res[,1])))
colnames(MtgAll) <- c("ASV", "Method+Data")

Mtg_allsig<-rbind(MtgP1,MtgP2, MtgP3, MtgAll)

Mtgcount<-plyr::ddply(Mtg_allsig, "ASV", transform, count = length(ASV))
duplic<-tibble(Mtgcount$ASV[which(Mtgcount$count >= 2)], Mtgcount$Method.Data[which(Mtgcount$count >= 2)])


replace <-paste(duplic$`Mtgcount$Method.Data[which(Mtgcount$count >= 2)]`[which(duplic$`Mtgcount$ASV[which(Mtgcount$count >= 2)]` ==  unique(duplic$`Mtgcount$ASV[which(Mtgcount$count >= 2)]`)[1])], collapse = "")
tmp<-tibble(unique(duplic$`Mtgcount$ASV[which(Mtgcount$count >= 2)]`)[1], replace)
colnames(tmp) <- c("ASV", "Method+Data")
replacetab <-tmp

for (i in 2:length(unique(duplic$`Mtgcount$ASV[which(Mtgcount$count >= 2)]`))) {
  replace <-paste(duplic$`Mtgcount$Method.Data[which(Mtgcount$count >= 2)]`[which(duplic$`Mtgcount$ASV[which(Mtgcount$count >= 2)]` ==  unique(duplic$`Mtgcount$ASV[which(Mtgcount$count >= 2)]`)[i])], collapse = "")
  tmp<-tibble(unique(duplic$`Mtgcount$ASV[which(Mtgcount$count >= 2)]`)[i], replace)
  colnames(tmp) <- c("ASV", "Method+Data")
  replacetab<-rbind(replacetab, tmp)
}

Mtg_allsig<-Mtg_allsig[-which(Mtg_allsig$ASV %in% replacetab$ASV),]
Mtg_allsig<-rbind(Mtg_allsig, replacetab)

Mtg_allsig<-cbind(Mtg_allsig, as(tax_table(filtered_ps003)[Mtg_allsig$ASV, ], "matrix"))
saveRDS(Mtg_allsig, "metagenomseq//full_res_table_mtg")

Mtg_allsig.print <- Mtg_allsig
Mtg_allsig.print$ASV <- NULL
rownames(Mtg_allsig.print) <- NULL
Mtg_allsig.print

#None for ANCOM, so will concatenate mtg and des into one table

fullsigtab<-rbind(Mtg_allsig.print, deseq_allsig.print)
fullsigtab_esv<-rbind(Mtg_allsig, deseq_allsig)
fullsigtab




```



## Visualization of significant taxa
```{r visualization_fun}
### functions to plot
make_vis_plots <- function(ps_norm, grouping, tax, plot_type=c('box', 'bar')){
  # ps should be a normalized (DESeq or CSS) phyloseq object
  # grouping should match the column name in the sample_data
  # tax is a taxonomical bin id (ASV) in the counts table to plot
  
  # subset phyloseq object to select ASV of interest
  ps_filt=prune_taxa(taxa_names(ps_norm) %in% tax, ps_norm)
  
  # get normalized counts
  plot_table<-data.table(otu_table(ps_filt), keep.rownames=TRUE)[rn %in% tax]
  # add very small value, min/100000 to 0
  plot_table <- melt(plot_table, id.vars='rn')
  plot_table$value <- plot_table$value+min(plot_table[value!=0]$value)/100000
  
  # add metadata
  groupDT=data.table(data.frame(sample_data(ps_filt)[, c(grouping, 'Within.study.sampling.date')]), keep.rownames=TRUE)
  setnames(groupDT, 'rn', 'variable')
  plot_table <- merge(plot_table, groupDT, by='variable', all.x=TRUE)
  
  # change variable to general name
  setnames(plot_table, grouping, 'Group')

  # boxplot
  if(plot_type=='box'){
    ggplot(data=plot_table, aes(x=Within.study.sampling.date, y = value, fill=Group)) + 
      geom_boxplot(outlier.color=NA) +
      geom_jitter(position=position_jitterdodge(0.2), cex=1.5, color="gray44") + 
      labs(title =deparse(substitute(ps_norm)), x='', y ='Proportional counts, log scale') + 
      scale_y_log10() + 
      scale_fill_manual(values=sgColorPalette)+
      theme_minimal() + facet_wrap(~rn, scales='free', ncol=3)+
      theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
  } else if (plot_type=='bar'){
    plot_table2 <- plot_table[, list(mean_ct=mean(value), sem=sd(value)/sqrt(.N)), by=c('Group', 'Within.study.sampling.date', 'rn')]
    ggplot(data=plot_table2, aes(x=Within.study.sampling.date, y =mean_ct, fill=Group)) + 
      geom_bar(stat='identity', position=position_dodge()) +
      geom_errorbar(aes(ymin=mean_ct-sem, ymax=mean_ct+sem), width=0.2, position=position_dodge(0.9))+ 
      labs(title =deparse(substitute(ps_norm)), x='', y ='Proportional counts, 0 to 1 scale') + 
      #scale_y_log10() + 
      scale_fill_manual(values=sgColorPalette)+
      theme_minimal() + facet_wrap(~rn, scales='free', ncol=3)+
      theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
  }
}

```

```{r visualization_sig}
######BOXPLOT of significant ones
# make significant taxa into one table so that all pvalues retained
significant_tax=NULL
significant_tax <- merge(data.table(deseq_res_P1[[2]], keep.rownames=TRUE)[, list(rn, deseq_P1_adjp=padj)],
                         data.table(deseq_res_P2[[2]], keep.rownames=TRUE)[, list(rn, deseq_P2_adjp=padj)],
                         by='rn', all=TRUE)
significant_tax <- merge(significant_tax,
                         data.table(deseq_res_P3[[2]], keep.rownames=TRUE)[, list(rn, deseq_P3_adjp=padj)],
                         by='rn', all=TRUE)
significant_tax <- merge(significant_tax,
                         data.table(bla[[2]], keep.rownames=TRUE)[, list(rn, deseq_timeseries_adjp=padj)],
                         by='rn', all=TRUE)
significant_tax <- merge(significant_tax,
                         data.table(zig_res_P1[[2]], keep.rownames=TRUE)[, list(rn, mtgseq_P1_adjp=adjPvalues)],
                         by='rn', all=TRUE)
significant_tax <- merge(significant_tax,
                         data.table(zig_res_P2[[2]], keep.rownames=TRUE)[, list(rn, mtgseq_P2_adjp=adjPvalues)],
                         by='rn', all=TRUE)
significant_tax <- merge(significant_tax,
                         data.table(zig_res_P3[[2]], keep.rownames=TRUE)[, list(rn, mtgseq_P3_adjp=adjPvalues)],
                         by='rn', all=TRUE)
significant_tax <- merge(significant_tax,
                         data.table(zig_res_all[[2]], keep.rownames=TRUE)[, list(rn, mtgseq_timeseries_adjp=adjPvalues)],
                         by='rn', all=TRUE)

# remove nothing
significant_tax <- significant_tax[rn!='nothing']

# write results
write.csv(significant_tax, file=paste0(output_data, 'Significant_res_deseq_q', deseq_cut, '_mtgseq_q', mtgseq_cut, '.csv'), row.names=FALSE)
          
datatable(significant_tax)

# also, find taxonomical annotations
# NOTE: single ASV may have multiple annotations due to tie hits
#Changing var all_tax_data to tax_table since I don't have this object since I don't have all_tax_data as a object,
datatable(tax_table(ps_not_norm_comp)[rownames(tax_table(ps_not_norm_comp)) %in% significant_tax$rn])
```

### DESeq results
```{r visualization_sig_deseq, fig.width=12}
## plot
# common by deseq
com_deseq_taxa=significant_tax[!is.na(deseq_P1_adjp) & !is.na(deseq_P2_adjp) & !is.na(deseq_P3_adjp)]

if(nrow(com_deseq_taxa)>0){
  print(make_vis_plots(ps_TSS_norm_pass_min_postDD_sup003, 'phenotype', com_deseq_taxa$rn, 'box'))
} else {
  print('no common DESeq significant taxa')
}
```

### DESeq timeseries results
```{r visualization_sig_deseq_ts, fig.width=12, fig.height=9}
# deseq timeseries
if(nrow(significant_tax[!is.na(deseq_timeseries_adjp)])>0){
  print(make_vis_plots(ps_TSS_norm_pass_min_postDD_sup003, 'phenotype', significant_tax[!is.na(deseq_timeseries_adjp)]$rn, 'box'))
  # plot bar as well
  print(make_vis_plots(ps_TSS_norm_pass_min_postDD_sup003, 'phenotype', significant_tax[!is.na(deseq_timeseries_adjp)]$rn, 'bar'))
} else {
  print('no DESeq timeseries significant taxa')
}
```

### metagenomeSeq results
```{r visualization_sig_mtgseq, fig.width=12, fig.height=3}
# common by metagenomeseq
com_mtgseq_taxa=significant_tax[!is.na(mtgseq_P1_adjp) & !is.na(mtgseq_P2_adjp) & !is.na(mtgseq_P3_adjp)]

if(nrow(com_mtgseq_taxa)>0){
  print(make_vis_plots(ps_TSS_norm_pass_min_postDD_sup003, 'phenotype', com_mtgseq_taxa$rn, 'box'))
} else {
  print('no common metagenomeSeq significant taxa')
}
```
### Meta_genome timeseries results
```{r visualization_sig_mtg_ts, fig.width=12, fig.height=9}
# mtgseq timeseries
if(nrow(significant_tax[!is.na(mtgseq_timeseries_adjp)])>0){
  print(make_vis_plots(ps_TSS_norm_pass_min_postDD_sup003, 'phenotype', significant_tax[!is.na(mtgseq_timeseries_adjp)]$rn[1:6], 'box'))
  # plot bar as well
  print(make_vis_plots(ps_TSS_norm_pass_min_postDD_sup003, 'phenotype', significant_tax[!is.na(mtgseq_timeseries_adjp)]$rn[1:6], 'bar'))
} else {
  print('no Mtgseq timeseries significant taxa')
}

if(nrow(significant_tax[!is.na(mtgseq_timeseries_adjp)])>0){
  print(make_vis_plots(ps_TSS_norm_pass_min_postDD_sup003, 'phenotype', significant_tax[!is.na(mtgseq_timeseries_adjp)]$rn[7:12], 'box'))
  # plot bar as well
  print(make_vis_plots(ps_TSS_norm_pass_min_postDD_sup003, 'phenotype', significant_tax[!is.na(mtgseq_timeseries_adjp)]$rn[7:12], 'bar'))
} else {
  print('no Mtgseq timeseries significant taxa')
}

if(nrow(significant_tax[!is.na(mtgseq_timeseries_adjp)])>0){
  print(make_vis_plots(ps_TSS_norm_pass_min_postDD_sup003, 'phenotype', significant_tax[!is.na(mtgseq_timeseries_adjp)]$rn[13:18], 'box'))
  # plot bar as well
  print(make_vis_plots(ps_TSS_norm_pass_min_postDD_sup003, 'phenotype', significant_tax[!is.na(mtgseq_timeseries_adjp)]$rn[13:18], 'bar'))
} else {
  print('no Mtgseq timeseries significant taxa')
}

if(nrow(significant_tax[!is.na(mtgseq_timeseries_adjp)])>0){
  print(make_vis_plots(ps_TSS_norm_pass_min_postDD_sup003, 'phenotype', significant_tax[!is.na(mtgseq_timeseries_adjp)]$rn[19:24], 'box'))
  # plot bar as well
  print(make_vis_plots(ps_TSS_norm_pass_min_postDD_sup003, 'phenotype', significant_tax[!is.na(mtgseq_timeseries_adjp)]$rn[19:24], 'bar'))
} else {
  print('no Mtgseq timeseries significant taxa')
}

if(nrow(significant_tax[!is.na(mtgseq_timeseries_adjp)])>0){
  print(make_vis_plots(ps_TSS_norm_pass_min_postDD_sup003, 'phenotype', significant_tax[!is.na(mtgseq_timeseries_adjp)]$rn[25:27], 'box'))
  # plot bar as well
  print(make_vis_plots(ps_TSS_norm_pass_min_postDD_sup003, 'phenotype', significant_tax[!is.na(mtgseq_timeseries_adjp)]$rn[25:27], 'bar'))
} else {
  print('no Mtgseq timeseries significant taxa')
}
```

# CCA and visualization
Compare resulting amplicon data between and within sample types by canonical correlation analysis, regression profiling, and visualization (e.g. non-metric multi-dimensional scaling [NMDS], principle coordinates of analysis, principle component analysis).

## Constrained by status A or N
```{r cca_ind}
plotting_phenotype_consPcoA <- function(ps,title){
  fam_6<-names(table(sample_data(ps)$Family.group.ID)[table(sample_data(ps)$Family.group.ID) == 6])
  ps_6fam<-prune_samples(sample_data(ps)$Family.group.ID %in% fam_6,ps )
  ps_pcoa_ord <- ordinate(
    physeq = ps_6fam, 
    method = "CAP", 
    distance = "bray",
    formula = ~ phenotype
    )
  p<-plot_ordination(
    physeq = ps_6fam, 
    ordination = ps_pcoa_ord, 
    color = "phenotype", 
    axes = c(1,2),
    title= paste("Constrained PcoA",title,"ordinated by phenotype with all timepoints")
    ) + 
    geom_point( size = 2) +
    scale_color_manual(values=sgColorPalette)+
    theme_minimal()+
    theme(text = element_text(size =10), plot.title = element_text(size=10))
  
    #sum_pcoA_DesEq<-summary(ps_pcoa_ord)
    erie_bray_sum_pcoA <- phyloseq::distance(ps, method = "bray")
    sampledf <- data.frame(sample_data(ps))
    beta_di<-betadisper(erie_bray_sum_pcoA, sampledf$Family.group.ID)
to_return<-list()
to_return[[1]]<-p
to_return[[2]]<-beta_di
  return(to_return)
  }

#With Deseq
DeSeq_distance<-plotting_phenotype_consPcoA(ps_DeSeq_norm_pass_min_postDD_sup003, "Deseq")
# plot
DeSeq_distance[[1]]

#same with CSS 
CSS_distance<-plotting_phenotype_consPcoA(ps_CSS_norm_pass_min_postDD_sup003, "CSS")
# plot
CSS_distance[[1]]
```

## Constrained by family
```{r cca_family}
#plotting
#Now we have: 803 taxa and 559 samples

#Looking at the family fro the complete set of samples

#Keeping the same ordination but filtering to the families with only 6 point to help vizualize the plot

#Looking at NORMALIZATION
plotting_Fam_consPcoA <- function(ps,title){
  fam_6<-names(table(sample_data(ps)$Family.group.ID)[table(sample_data(ps)$Family.group.ID) == 6])
  ps_6fam<-prune_samples(sample_data(ps)$Family.group.ID %in% fam_6,ps )
  sample_data(ps_6fam)$Family.group.ID <- paste0('fam', as.character(sample_data(ps_6fam)$Family.group.ID))
  ps_pcoa_ord <- ordinate(
    physeq = ps_6fam, 
    method = "CAP", 
    distance = "bray",
    formula = ~ Family.group.ID
    )
  p<-plot_ordination(
    physeq = ps_6fam, 
    ordination = ps_pcoa_ord, 
    color = "Family.group.ID", 
    axes = c(1,2),
    title= paste("Constrained PcoA",title,"ordinated by families with all timepoints")
    ) + 
    geom_point( size = 2) +
    theme_minimal()+
    theme(text = element_text(size =10), plot.title = element_text(size=10), legend.position='none')
  
    #sum_pcoA_DesEq<-summary(ps_pcoa_ord)
    erie_bray_sum_pcoA <- phyloseq::distance(ps, method = "bray")
    sampledf <- data.frame(sample_data(ps))
    beta_di<-betadisper(erie_bray_sum_pcoA, sampledf$Family.group.ID)
to_return<-list()
to_return[[1]]<-p
to_return[[2]]<-beta_di
  return(to_return)
  }

#With Deseq
DeSeq_distance<-plotting_Fam_consPcoA(ps_DeSeq_norm_pass_min_postDD_sup003, "Deseq")
# plot
DeSeq_distance[[1]]

#same with CSS 
CSS_distance<-plotting_Fam_consPcoA(ps_CSS_norm_pass_min_postDD_sup003, "CSS")
# plot
CSS_distance[[1]]

#the distance in those plot?
#average_distance_to_median
#pdf(file=paste0(output_data, "Figures/Distance_DeSeq_CSS_", Sys.Date(), ".pdf"))
boxplot(DeSeq_distance[[2]]$distances,CSS_distance[[2]]$distances, names=c("DeSeq", "CSS"), 
        xlab = "Type of Normalization", ylab = "Distance on Component 1 & 2", main ="Intragroup distance for each family")
#dev.off()

```

# Diversity
Characterize and assess the diversity of each sample, and evaluate the extent of dissimilarity between the cohorts

## Alpha diversity
```{r alpha_diversity}
ER <- estimate_richness(ps_not_norm_comp, measures=c("Observed", "Chao1", "Shannon"))
ER <- cbind(ER, sample_data(ps_not_norm_comp)[row.names(ER), c("phenotype", "Family.group.ID", "Within.study.sampling.date")])
ER <- data.table(ER, keep.rownames = TRUE)
ER <- melt(ER, id.vars=c('rn', 'phenotype', "Family.group.ID", "Within.study.sampling.date"))

# plot
ggplot(data=ER[variable!='se.chao1'], aes(x=phenotype, y=value, fill=phenotype))+
  geom_boxplot(width=0.7, outlier.colour='white')+
  geom_jitter(size=1, position=position_jitter(width=0.1))+
  xlab('')+ylab('')+
  scale_fill_manual(values=sgColorPalette)+
  theme_minimal()+facet_wrap(~variable, scales='free')

# run t-test to check significance
ttest=NULL
for(alphad in c('Observed', 'Chao1', 'Shannon')){
  ttest_res=t.test(value ~ phenotype, data=ER[variable==alphad], var.equal=TRUE)
  ttest=rbindlist(list(ttest, data.table(alpha_index=alphad, pvalue=ttest_res$p.value)))
}

pander(ttest)
```

## Beta diversity
```{r beta_diversity}
#Let's do a PcoA #not much differences 
GP.ord <- ordinate(ps_DeSeq_norm_pass_min_postDD_sup003, "PCoA", "bray")
p2 = plot_ordination(ps_DeSeq_norm_pass_min_postDD_sup003, GP.ord, type="samples", color="phenotype") +
  geom_point( size = 1)+
  scale_color_manual(values=sgColorPalette)+
  theme_minimal()
p2
```


# PERMANOVA
non- parametric statistical approaches (ANOSIM, ADONIS, ANOVA, PERMANOVA, etc.) will be employed to determine the significance of noteworthy factors, such as digital phenotype, probiotic and/or antibiotic use

## PERMANOVA test
```{r permanova, results="asis"}
permanova <- function(physeq, factorName, ifnumeric, pmt=999){
  set.seed(1)
  braydist = phyloseq::distance(physeq, "bray")
  form <- as.formula(paste("braydist ~ ", c(factorName), sep = ""))
  metaDF=data.frame(sample_data(physeq)[, as.character(factorName)])
  # if numerical variable, make sure the class
  if(ifnumeric){
    metaDF[, factorName] <- as.numeric(metaDF[, factorName])
    factor_class='numeric'
  } else {
    factor_class='categorical'
  }
  perm <- adonis(form, permutations = pmt, metaDF)
  permDT=data.table(Variable=factorName, 
             FactorClass=factor_class,
             TotalN=perm$aov.tab['Total','Df']+1, 
             R2=perm$aov.tab[factorName, 'R2'], 
             pvalue=perm$aov.tab[factorName,'Pr(>F)'][1])
  return(permDT)
}
#betadispersion
#we keep only the cateory selected above as relevant 
tmp_metadat<-metadata_ok[,c(num_cat,fac_cat)]
#additionnal error to remove: not enough sample: 
tmp_metadat<-tmp_metadat[,-which(colnames(tmp_metadat) %in% c("Number.of.pet.reptiles","Number.of.pet.horses", "Pet.horse"))]
#additionnal error to remove: filled with only NA or one factor, cant do permutest on it due to adonis function requirements
col_levels<-sapply(tmp_metadat, levels)
col_levelscount<-sapply(col_levels, length)
tmp_metadat_1 <- tmp_metadat
#Since there are no numerics based on code below, will drop all that dont have 2 or more levels
#tmp_metadat[,which(sapply(tmp_metadat, class) == "numeric")]
tmp_metadat <- tmp_metadat[,which(col_levelscount >= 2)]

set.seed(1)
pval_factors_diper=c()
nb_samples_disper=c()
for (i in 1:length(tmp_metadat)){
  #cat (i,"\t")
  test_map<-tmp_metadat[!is.na(tmp_metadat[,i]) & tmp_metadat[,i] != "" ,]
  ps.tmp<-copy(ps_DeSeq_norm_pass_min_postDD_sup003)
  sample_data(ps.tmp) <- test_map
  df_metadata <- data.frame(sample_data(ps.tmp))
  df_metadata<-df_metadata[df_metadata[,colnames(test_map)[i]] != "",]
  # use prune_samples instead of subset_samples
  keepid=!is.na(get_variable(ps.tmp, colnames(test_map)[i])) &
    get_variable(ps.tmp, colnames(test_map)[i])!='' &
    get_variable(ps.tmp, colnames(test_map)[i])!='NA' 
  ps.tmp <- prune_samples(keepid, ps.tmp)
  #ps.tmp <- subset_samples(ps.tmp, colnames(test_map)[i] !="")
  tmp_nb_samples<-dim(otu_table(ps.tmp))[2]
  OTU_tables_bray <- phyloseq::distance(ps.tmp, method = "bray")
  beta <- betadisper(OTU_tables_bray, df_metadata[,colnames(test_map)[i]])
  tmp<-permutest(beta)
  tmp<-tmp$tab$`Pr(>F)`[1]
  pval_factors_diper<-c(pval_factors_diper,tmp)
  nb_samples_disper<-c(nb_samples_disper,tmp_nb_samples)}
#correct the p.value 
names(pval_factors_diper)<-colnames(tmp_metadat)
pval_factors_diper<-p.adjust(pval_factors_diper, method = "fdr")
to_remove_betadis<-names(pval_factors_diper)[pval_factors_diper<0.05]
  
# list of permanova variables
#meta_cat <- tibble(col_levelscount >= 2, colnames(tmp_metadat_1), sapply(tmp_metadat_1, class))
#rownames(meta_cat) <- colnames(tmp_metadat_1)
#colnames(meta_cat) <- c("permanova", "varname", "type")
#meta_cat$type <- gsub("factor", "Categorical", meta_cat$type)
#meta_cat$type <- gsub("numerical", "Continuous", meta_cat$type)

#meta_cat file listed phenotype as false for permanova, but I will add it back in)
meta_cat$permanova[which(meta_cat$varname == "phenotype")] <- "Categorical"
permanova_var=meta_cat[which(meta_cat$permanova!=FALSE),]

permanova_var$permanova[which(permanova_var$varname %in% c(dict_1_items, dict_2_items, "Stool.frequency"))] <- rep("Continuous", length(permanova_var$permanova[which(permanova_var$varname %in% c(dict_1_items, dict_2_items, "Stool.frequency"))]))

set.seed(1)
permanova_res=NULL
for(j in 1:nrow(permanova_var)){
    #print(factorName1)
    #pander(table(sample_data(ps_DeSeq_norm_pass_min_postDD_sup003)[, factorName1]))
  # variable name (as.characteradded)
  var_name=as.character(permanova_var$varname[j])
  # remove all NAs
  keepid=!is.na(get_variable(ps_DeSeq_norm_pass_min_postDD_sup003, var_name)) &
    get_variable(ps_DeSeq_norm_pass_min_postDD_sup003, var_name)!='NA' &
    get_variable(ps_DeSeq_norm_pass_min_postDD_sup003, var_name)!=''
  tmp_ps <- prune_samples(keepid, ps_DeSeq_norm_pass_min_postDD_sup003)
  
  # Check if there is more than 1 values (categories)
  if(uniqueN(sample_data(tmp_ps)[, var_name])>1){
    
    # if categorical
    if(permanova_var$permanova[j]=='Categorical'){
      # run permanova only if there are more than 1 groups
      p <- permanova(tmp_ps, factorName=var_name, ifnumeric=FALSE, pmt=999)
      permanova_res=rbindlist(list(permanova_res, p))
      rm(p)
    }
    # if continuous
    if(permanova_var$permanova[j]=='Continuous'){
      p <- permanova(tmp_ps, factorName=var_name, ifnumeric=TRUE, pmt=999)
      permanova_res=rbindlist(list(permanova_res, p))
      rm(p)
    }
  }
  rm(var_name)
}

# write
write.csv(permanova_res, file=paste0(output_data, 'PERMANOVA.csv'), row.names=FALSE)

# total number of variables tested
uniqueN(permanova_res$Variable)
# Factor class
pander(table(permanova_res$FactorClass))
# number of significant variables
uniqueN(permanova_res[pvalue<permanova_pcut]$Variable)



#and now removing the ones with betadispersion significant 
impacting_compo<-setdiff(permanova_res[pvalue<permanova_pcut]$Variable,  to_remove_betadis)

#and now the ones also significant between the two cohorts
impacting_compo<-impacting_compo[impacting_compo %in% c(names(all_chisquare))]
permanova_res<- permanova_res[permanova_res$Variable %in% impacting_compo,]

#removing LR predictions since those are essentially an indicator of phenotype and not confounding variables
permanova_res<-permanova_res[-which(permanova_res$Variable %in% c("LR10.probability.ASD..M3.", "LR5.probability.ASD..M3.", "LR6.probability.ASD..M3." , "LR10.prediction..M3.", "LR10.probability.not.ASD..M3.", "LR5.probability.not.ASD..M3." , "LR5.prediction..M3.", "LR6.prediction..M3." , "LR6.probability.not.ASD..M3.")),]

# sort
permanova_res <- permanova_res[order(R2, decreasing=TRUE)]
datatable(permanova_res)
write.csv(permanova_res, file=paste0(output_data, 'PERMANOV_betadis_imp_corhort.csv'), row.names=FALSE)

```

## Visualize permanova significant variables on PCoA
```{r plot_R2_value, fig.width=16, fig.height=40}
# function to plot PCoA, only for higher R2 value 
imp_factors<-permanova_res$Variable[permanova_res$R2 > 0.01]

imp<-list()
for (i in 1:length(imp_factors)){
if(anyNA(map[,imp_factors[i]]) == FALSE){
  imp[i] <- imp_factors[i]
}
}


impforpcoa<-unlist(imp)

add<-paste(impforpcoa, collapse = " + ")

#copy and paste form variable below into formula for pcoa for convenience (not sure why it does not work as an input for formula, but copy/paste as text works)
form<- as.formula(paste0("~ ", add))


#ordination formula only working with one variable in formula...
ps_pcoa <- ordinate(
  physeq = ps_DeSeq_norm_pass_min_postDD_sup003, 
  method = "CAP", 
  distance = "bray",
  #Did not include Toilet.cover and Meat/Seafood Longitudinal, Fruit..consumption.frequency...longitudinal. and LR10.prediction..M3. due to NA missing values which does not allow for ordination
  formula = ~Stool.frequency + Age..months. + Age..years. + Vitamin.D..consumption.frequency.)
title_prep<-impforpcoa

to_plot=list()
for (i in 1:4){
  to_plot[[i]] <- plot_ordination(
  physeq = ps_DeSeq_norm_pass_min_postDD_sup003, 
  ordination = ps_pcoa, 
  color = title_prep[i], 
  axes = c(1,2),
  title=title_prep[i]
) + 
  geom_point( size = 0.5) +
  theme(text = element_text(size =20), plot.title = element_text(size=15))
}
to_plot[[5]]<-plot_ordination(physeq = ps_DeSeq_norm_pass_min_postDD_sup003, ordination = ps_pcoa, type="taxa",title ="Taxa") + theme(text = element_text(size =15))
lay <- rbind(c(1),
             c(2),
             c(3),
             c(4),
             c(5))


#pdf(paste0(output_data,"confounding_factors.pdf",width=16,height=40))
grid.arrange(grobs = to_plot, layout_matrix = lay)
top_potential_confounds <- imp_factors
#dev.off()
```

```{r plot_imp_taxa}
#Let's have a look at the plot 
plot_ordination(physeq = ps_DeSeq_norm_pass_min_postDD_sup003, ordination = ps_pcoa, type="taxa",title ="Taxa") + theme(text = element_text(size =8))
#ok let's try to find the spcies that show some importance in this PCA
taxa.to.select<-vegan::scores(ps_pcoa)$species
#now plot it with no name for visibilty
rownames(taxa.to.select)<-c()
s.arrow(taxa.to.select) #the taxa that influence the most the plots are above 0.25
taxa.to.select.to.rem<-vegan::scores(ps_pcoa)$species[abs(vegan::scores(ps_pcoa)$species[,1])>0.1 | abs(vegan::scores(ps_pcoa)$species[,2])>0.1,]
#any overlap with the 5 important? 
rownames(bla[[2]]) %in% taxa.to.select.to.rem #NOPE!
```

## Comparison of Variance between Subjects and between Phenotypes
```{r variance}

#doing the same but w/ avg
tmpps <- prune_samples((ps_DeSeq_norm_pass_min_postDD_sup003@sam_data$Family.group.ID == "1"), ps_DeSeq_norm_pass_min_postDD_sup003)
tmppsA <- prune_samples(tmpps@sam_data$phenotype == "A", tmpps)
tmppsN <- prune_samples(tmpps@sam_data$phenotype == "N", tmpps)

A<-distance(tmppsA, "bray", type = "samples")
ave_distanceA=ave(c(A[1],A[2],A[3]))[1]

N<-distance(tmppsN, "bray", type = "samples")
ave_distanceN=ave(c(N[1],N[2],N[3]))[1]

tab<-tibble(ave_distanceA, ave_distanceN, tmpps@sam_data$Family.group.ID[1])
colnames(tab) <- c("AvgDistanceAut", "AvgDistanceNeu", "Family")


for(i in unique(ps_DeSeq_norm_pass_min_postDD_sup003@sam_data$Family.group.ID)){
tmpps <- prune_samples((ps_DeSeq_norm_pass_min_postDD_sup003@sam_data$Family.group.ID == i), ps_DeSeq_norm_pass_min_postDD_sup003)
tmppsA <- prune_samples(tmpps@sam_data$phenotype == "A", tmpps)
tmppsN <- prune_samples(tmpps@sam_data$phenotype == "N", tmpps)

A<-distance(tmppsA, "bray", type = "samples")
ave_distanceA=ave(c(A[1],A[2],A[3]))[1]

N<-distance(tmppsN, "bray", type = "samples")
ave_distanceN=ave(c(N[1],N[2],N[3]))[1]

tabtmp<-tibble(ave_distanceA, ave_distanceN, tmpps@sam_data$Family.group.ID[1])
colnames(tabtmp) <- c("AvgDistanceAut", "AvgDistanceNeu", "Family")

tab<-rbind(tab, tabtmp)
}

#tab
# run tests to check significance
taba<-tibble(tab$AvgDistanceAut, rep("A", length(tab$AvgDistanceAut)), tab$Family)
colnames(taba) <- c("AvgDistanceDiff_btwnTimepoints","phenotype", "Family" )

tabn<-tibble(tab$AvgDistanceNeu, rep("N", length(tab$AvgDistanceNeu)), tab$Family)
colnames(tabn) <- c("AvgDistanceDiff_btwnTimepoints","phenotype" , "Family")

finaltab2<-rbind(tabn, taba)

p <- ggplot(finaltab2, aes(x=phenotype, y=AvgDistanceDiff_btwnTimepoints)) + 
  geom_boxplot()
p + geom_jitter(shape=16, position=position_jitter(0.2))

# run tests to check significance
shapiro.test(finaltab2$AvgDistanceDiff_btwnTimepoints) #not normal we need a reanking test
wilcox.test(AvgDistanceDiff_btwnTimepoints ~ phenotype, data=finaltab2, var.equal=FALSE)

#still not significant


#paired wilcoxon
tmpps <- prune_samples((ps_DeSeq_norm_pass_min_postDD_sup003@sam_data$Family.group.ID == "1"), ps_DeSeq_norm_pass_min_postDD_sup003)
tmppsA <- prune_samples(tmpps@sam_data$phenotype == "A", tmpps)
tmppsN <- prune_samples(tmpps@sam_data$phenotype == "N", tmpps)

A<-distance(tmppsA, "bray", type = "samples")
distanceA=c(A[1],A[2],A[3])

N<-distance(tmppsN, "bray", type = "samples")
distanceN=c(N[1],N[2],N[3])

tab<-tibble(distanceA, distanceN, rep(tmpps@sam_data$Family.group.ID[1], length(distanceA)), c("Timepoint 1-2", "Timepoint 1-3", "Timepoint 2-3"))
colnames(tab) <- c("DistanceAut", "DistanceNeu", "Family", "Timepoint")


for(i in unique(ps_DeSeq_norm_pass_min_postDD_sup003@sam_data$Family.group.ID)[c(-1)]){
tmpps <- prune_samples((ps_DeSeq_norm_pass_min_postDD_sup003@sam_data$Family.group.ID == i), ps_DeSeq_norm_pass_min_postDD_sup003)
tmppsA <- prune_samples(tmpps@sam_data$phenotype == "A", tmpps)
tmppsN <- prune_samples(tmpps@sam_data$phenotype == "N", tmpps)

A<-distance(tmppsA, "bray", type = "samples")
distanceA=c(A[1],A[2],A[3])

N<-distance(tmppsN, "bray", type = "samples")
distanceN=c(N[1],N[2],N[3])

tabtmp<-tibble(distanceA, distanceN, rep(tmpps@sam_data$Family.group.ID[1], length(distanceA)),  c("Timepoint 1-2", "Timepoint 1-3", "Timepoint 2-3"))
colnames(tabtmp) <- c("DistanceAut", "DistanceNeu", "Family", "Timepoint")

tab<-rbind(tab, tabtmp)
}
tab_w_tp <- tab
#tab
# run tests to check significance
taba<-tibble(tab$DistanceAut, rep("A", length(tab$DistanceAut)), tab$Family, tab$Timepoint)
colnames(taba) <- c("Distances_btwnTimepoints","phenotype", "Family" , "Timepoint")

tabn<-tibble(tab$DistanceNeu, rep("N", length(tab$DistanceNeu)), tab$Family, tab$Timepoint)
colnames(tabn) <- c("Distances_btwnTimepoints","phenotype", "Family" , "Timepoint")

finaltab3<-rbind(tabn, taba)

p <- ggplot(finaltab3, aes(x=phenotype, y=Distances_btwnTimepoints)) + 
  geom_boxplot()
p + geom_jitter(shape=16, position=position_jitter(0.2))

# run tests to check significance
wilcox.test(tab$DistanceAut, tab$DistanceNeu, paired = TRUE)


#still not significant






#Will do permutations


#with avgs
permutation_meandist_gen<-function(x){
  ptab <- x
  ptab$permu_label<- ptab$phenotype[shuffle(ptab$phenotype)]

  mean(ptab$AvgDistanceDiff_btwnTimepoints[which(ptab$permu_label == "A")]) -
  mean(ptab$AvgDistanceDiff_btwnTimepoints[which(ptab$permu_label == "N")])

}
permu_means<-replicate(1000, permutation_meandist_gen(finaltab2))

diff.means<-mean(finaltab2$AvgDistanceDiff_btwnTimepoints[which(finaltab2$phenotype == "A")]) -
  mean(finaltab2$AvgDistanceDiff_btwnTimepoints[which(finaltab2$phenotype == "N")])

sig <- sum(permu_means > diff.means)

hist(permu_means) 



# with raw values
permutation_meandist_gen<-function(x){
  ptab <- x
  ptab$permu_label<- ptab$phenotype[shuffle(ptab$phenotype)]

  mean(ptab$Distances_btwnTimepoints[which(ptab$permu_label == "A")]) -
  mean(ptab$Distances_btwnTimepoints[which(ptab$permu_label == "N")])

}
set.seed(1)
permu_means<-replicate(1000, permutation_meandist_gen(finaltab3))

diff.means<-mean(finaltab3$Distances_btwnTimepoints[which(finaltab2$phenotype == "A")]) -
  mean(finaltab3$Distances_btwnTimepoints[which(finaltab2$phenotype == "N")])

sig <- as.numeric(sum(permu_means >= diff.means))
pval<-sig/1000

pval

{hist(permu_means)
 abline(v = diff.means, col = "red")}

{plot(density(permu_means))
  abline(v = diff.means, col = "red")}


#organized by family

permutation_meandist_gen_by_fam<-function(x){
  ptab <- x
  tmp <- ptab[which(ptab$Family == ptab$Family[1]),]
  tmp$permu_label<- tmp$phenotype[shuffle(tmp$phenotype)]
  ptab_all <- tmp
  
  for (i in 2:length(unique(ptab$Family))){
  tmp <- ptab[which(ptab$Family == unique(ptab$Family)[i]),]
  tmp$permu_label<- tmp$phenotype[shuffle(tmp$phenotype)]
  ptab_all <- rbind(ptab_all, tmp)
  }
  

  mean(ptab_all$Distances_btwnTimepoints[which(ptab_all$permu_label == "A")]) -
  mean(ptab_all$Distances_btwnTimepoints[which(ptab_all$permu_label == "N")])

}
set.seed(1)
permu_means_by_fam<-replicate(1000, permutation_meandist_gen_by_fam(finaltab3))


sig <- as.numeric(sum(permu_means >= diff.means))
pval_by_fam<-sig/1000

pval_by_fam

{hist(permu_means_by_fam)
 abline(v = diff.means, col = "red")}

{plot(density(permu_means_by_fam))
  abline(v = diff.means, col = "red")}



# Now with difference between A and N at each time point, then taking mean


#Since they are in order by family and timepoint, I can subtract across

#view to make sure
#finaltab3[which(finaltab3$phenotype == "A"),]
#finaltab3[which(finaltab3$phenotype == "N"),]





# First just by timepoint
permutation_meandist_gen_by_fam_diff<-function(x){
  ptab <- x
  tmp <- ptab[which(ptab$Family == ptab$Family[1]),]
  tmp$permu_label<- tmp$phenotype[shuffle(tmp$phenotype)]
  ptab_all <- tmp
  
  for (i in 2:length(unique(ptab$Family))){
  tmp <- ptab[which(ptab$Family == unique(ptab$Family)[i]),]
  tmp$permu_label<- tmp$phenotype[shuffle(tmp$phenotype)]
  ptab_all <- rbind(ptab_all, tmp)
  }
  

  mean(ptab_all$Distances_btwnTimepoints[which(ptab_all$permu_label == "A")]-
  ptab_all$Distances_btwnTimepoints[which(ptab_all$permu_label == "N")])

}

fintab_1_2<-finaltab3[which(finaltab3$Timepoint == "Timepoint 1-2"),]
fintab_1_3<-finaltab3[which(finaltab3$Timepoint == "Timepoint 1-3"),]
fintab_2_3<-finaltab3[which(finaltab3$Timepoint == "Timepoint 2-3"),]

set.seed(1)
permu_means_by_fam12<-replicate(1000, permutation_meandist_gen_by_fam_diff(fintab_1_2))
mean_difference<-mean(fintab_1_2$Distances_btwnTimepoints[which(fintab_1_2$phenotype == "A")] -fintab_1_2$Distances_btwnTimepoints[which(fintab_1_2$phenotype == "N")])
sig <- as.numeric(sum(permu_means_by_fam12 >= mean_difference))
pval_by_fam12<-sig/1000

set.seed(1)
permu_means_by_fam13<-replicate(1000, permutation_meandist_gen_by_fam_diff(fintab_1_3))
mean_difference<-mean(fintab_1_3$Distances_btwnTimepoints[which(fintab_1_3$phenotype == "A")] -fintab_1_3$Distances_btwnTimepoints[which(fintab_1_3$phenotype == "N")])
sig <- as.numeric(sum(permu_means_by_fam13 >= mean_difference))
pval_by_fam13<-sig/1000


set.seed(1)
permu_means_by_fam23<-replicate(1000, permutation_meandist_gen_by_fam_diff(fintab_2_3))
mean_difference<-mean(fintab_2_3$Distances_btwnTimepoints[which(fintab_2_3$phenotype == "A")] -fintab_2_3$Distances_btwnTimepoints[which(fintab_2_3$phenotype == "N")])
sig <- as.numeric(sum(permu_means_by_fam23 >= mean_difference))
pval_by_fam23<-sig/1000


#All_together
permutation_meandist_gen_by_fam_diff_all<-function(x){
  ptab <- x
  tmp <- ptab[which(ptab$Family == ptab$Family[1]),]
  tmp_time <- tmp[which(tmp$Timepoint == unique(tmp$Timepoint)[1]),]
  tmp_time$permu_label<- tmp_time$phenotype[shuffle(tmp_time$phenotype)]
  tmp_time_all <- tmp_time
  
  for (b in 2:3) {
    tmp_time <- tmp[which(tmp$Timepoint == unique(tmp$Timepoint)[b]),]
    tmp_time$permu_label<- tmp_time$phenotype[shuffle(tmp_time$phenotype)]
    tmp_time_all <- rbind(tmp_time_all, tmp_time)
    
  }
  
  ptab_all <-tmp_time_all
  
  for (i in 2:length(unique(ptab$Family))){
  tmp <- ptab[which(ptab$Family == unique(ptab$Family)[i]),]
  tmp_time <- tmp[which(tmp$Timepoint == unique(tmp$Timepoint)[1]),]
  tmp_time$permu_label<- tmp_time$phenotype[shuffle(tmp_time$phenotype)]
  tmp_time_all <- tmp_time
  
    for (b in 2:3) {
    tmp_time <- tmp[which(tmp$Timepoint == unique(tmp$Timepoint)[b]),]
    tmp_time$permu_label<- tmp_time$phenotype[shuffle(tmp_time$phenotype)]
    tmp_time_all <- rbind(tmp_time_all, tmp_time)
    
    }
  
  ptab_all <- rbind(ptab_all, tmp_time_all)
  }
  

  mean(ptab_all$Distances_btwnTimepoints[which(ptab_all$permu_label == "A")]-
  ptab_all$Distances_btwnTimepoints[which(ptab_all$permu_label == "N")])

}

permu_means_by_fam_shuffled_while_maintaining_tp<-replicate(1000, permutation_meandist_gen_by_fam_diff(finaltab3))
mean_difference<-mean(finaltab3$Distances_btwnTimepoints[which(finaltab3$phenotype == "A")] -finaltab3$Distances_btwnTimepoints[which(finaltab3$phenotype == "N")])
sig <- as.numeric(sum(permu_means_by_fam_shuffled_while_maintaining_tp >= mean_difference))
pval_by_fam_all<-sig/1000

{plot(density(permu_means_by_fam_shuffled_while_maintaining_tp))
  abline(v = mean_difference, col = "red")}



```


## Without NA points

```{r plot_wo_na}
# function to plot PCoA without NA points
wo_na_pcoa <- function(ps, pvar, ord_res){
  # ord_res: ordinated object
  
  keepid=!is.na(get_variable(ps, pvar)) &
    get_variable(ps, pvar)!='NA' &
    get_variable(ps, pvar)!=''
  tmp_ps <- prune_samples(keepid, ps)
  
  # get subset counts and metadata together
  DF <- cbind(ord_res$vectors[row.names(sample_data(tmp_ps)), 1:2], sample_data(tmp_ps)[, pvar])
  setnames(DF, pvar, 'testvar')
  
  # get eigenvalues
  eig=(ord_res$values$Eigenvalues/sum(ord_res$values$Eigenvalues))[1:2]*100
  
  p <- ggplot(data=DF, aes(x=Axis.1, y=Axis.2, colour=testvar))+
    geom_point(size=2)+
    ggtitle(pvar)+
    xlab(paste0('Axis.1 [', format(eig[1], digits=3), '%]'))+
    ylab(paste0('Axis.2 [', format(eig[2], digits=3), '%]'))+
    theme_minimal()+
    theme(legend.title=element_blank(), legend.position="bottom")
    
  print(p)
}
```


### Looking into confounding variables
```{r confounds}

#Hard to find a confounding variable in impfactors that does not have a lot of NAs (no NAs required for DESEQ2)
runDESeq_time_confound <- function(ps, dcut, confound){
  diagdds = phyloseq_to_deseq2(ps, as.formula(paste0("~ ", confound, "+ Within.study.sampling.date"))) 
  diagdds <- estimateSizeFactors(diagdds, type = "poscounts")
  diagdds <- DESeq(diagdds,fitType="parametric", betaPrior = FALSE) 
  #resultsNames(diagdds): to determine the constrast
  res = results(diagdds, contrast = c(confound, levels(map[,confound])[1], levels(map[,confound])[2]))
  res$padj[is.na(res$padj)] = 1
  sig <- res[res$padj < dcut,]
  if (dim(sig)[1] == 0) 
  {sigtab<- as.data.frame(1, row.names="nothing")
  colnames(sigtab) <- 'padj'}
  else 
  {
    sigtab <- data.frame(sig)
  }
  return(list(res, sigtab))
}

run_metagenom_seq_confound<-function(ps,maxit, mcut, confound){
  p_metag<-phyloseq_to_metagenomeSeq(ps)
  #filtering at least 4 samples 
  p_metag= cumNorm(p_metag, p=0.75)
  normFactor =normFactors(p_metag)
  normFactor =log2(normFactor/median(normFactor) + 1)
  #mod = model.matrix(~ASDorNeuroT +PairASD+ normFactor)
  mod = model.matrix(as.formula(paste0("~ ", confound, "+ Within.study.sampling.date +normFactor")), data = pData(p_metag))
  settings =zigControl(maxit =maxit, verbose =FALSE)
  #settings =zigControl(tol = 1e-5, maxit = 30, verbose = TRUE, pvalMethod = 'bootstrap')
  fit =fitZig(obj = p_metag, mod = mod, useCSSoffset = FALSE, control = settings)
  #Note: changed fit$taxa to fit@taxa in light of error (probably from newer metagenomeseq ver.)
  res_fit<-MRtable(fit, number = length(fit@taxa))
  res_fit_nonfiltered <- copy(res_fit)
  res_fit<-res_fit[res_fit$adjPvalues<mcut,]
  #finally remove the ones that are not with enough samples
  #mean_sample<-mean(calculateEffectiveSamples(fit))
  #res_fit<-res_fit[res_fit$`counts in group 0` & res_fit$`counts in group 1` > mean_sample,]
  Min_effec_samp<-calculateEffectiveSamples(fit)
  Min_effec_samp<-Min_effec_samp[ names(Min_effec_samp)  %in% rownames(res_fit)] #####there is a bug here 
  #manually removing the ones with "NA"
  res_fit<-res_fit[grep("NA",rownames(res_fit), inv=T),]
  res_fit$Min_sample<-Min_effec_samp
  res_fit<-res_fit[res_fit$`+samples in group 0` >= Min_effec_samp & res_fit$`+samples in group 1` >= Min_effec_samp,]
  return(list(res_fit_nonfiltered, res_fit))
}

cat_confounds<-permanova_res$Variable[permanova_res$FactorClass == "categorical"]
num_confounds<-permanova_res$Variable[permanova_res$FactorClass == "numeric"]

toomanyNAs<-list()
for (i in 1:length(cat_confounds)){
tmp<-is.na(filtered_ps003@sam_data[,cat_confounds[i]])
if (length(rownames(tmp)[which(tmp == TRUE)]) >=40) {
  toomanyNAs[i] <-cat_confounds[i]
}
}
cat_confounds<-cat_confounds[-which(cat_confounds %in% unlist(toomanyNAs))]

confound <- cat_confounds[1]
#some are listed as logical
write.csv(sample_data(filtered_ps003), "sam_data.csv")
map<-read.csv("sam_data.csv")
map[,confound] <- as.factor(map[,confound])
rownames(map) <- map$Biospecimen.Barcode
sample_data(filtered_ps003) <- map
filtered_ps003NAout<-prune_samples(!is.na(map[,confound]), filtered_ps003)
if(levels(map[,confound]) == 2){
deseqcon<-runDESeq_time_confound(filtered_ps003NAout, deseq_cut, confound = confound)
mtgcon<-run_metagenom_seq_confound(filtered_ps003NAout, 30, mtgseq_cut, confound = confound)
affected_taxa <-c(rownames(mtgcon[[2]]), row.names(deseqcon[2][[1]]) )
} else{
  mtgcon<-run_metagenom_seq_confound(filtered_ps003NAout, 30, mtgseq_cut, confound = confound)
  affected_taxa <-rownames(mtgcon[[2]])
}


for (i in 2:length(cat_confounds)) {
  confound <- cat_confounds[i]
  #some are listed as logical
  write.csv(sample_data(filtered_ps003), "sam_data.csv")
  map<-read.csv("sam_data.csv")
  map[,confound] <- as.factor(map[,confound])
  rownames(map) <- map$Biospecimen.Barcode
  sample_data(filtered_ps003) <- map
  filtered_ps003NAout<- prune_samples(!is.na(map[,confound]), filtered_ps003)
  if(length(levels(map[,confound])) == 2){
  deseqcon<-runDESeq_time_confound(filtered_ps003NAout, deseq_cut, confound = confound)
  mtgcon<-run_metagenom_seq_confound(filtered_ps003NAout, 30, mtgseq_cut, confound = confound)
  tmp <-c(rownames(mtgcon[[2]]), row.names(deseqcon[2][[1]]) )
  } else{
  mtgcon<-run_metagenom_seq_confound(filtered_ps003NAout, 30, mtgseq_cut, confound = confound)
  tmp <-rownames(mtgcon[[2]])
  }
  affected_taxa<-c(affected_taxa, tmp)
}

affected_taxa_cat<-unique(affected_taxa)




#Testing to see if numerical variables differ in means using wilcox or t-tests
tmp<-shapiro.test(map[,num_confounds[1]])
  if (tmp$p.value <= 0.05) {
    res<-wilcox.test(as.formula(paste(num_confounds[1], "~ phenotype")), data=map, var.equal = FALSE)
    tab<-tibble(num_confounds[1], res$p.value, "wilcox")
    colnames(tab) <- c("Var", "p.value", "Type")
    numerical_test_btwn_pheno <- tab
  }else{
    res<-t.test(as.formula(paste(num_confounds[1], "~ phenotype")), data=map)
    tab<-tibble(num_confounds[1], res$p.value, "t.test")
    colnames(tab) <- c("Var", "p.value", "Type")
    numerical_test_btwn_pheno <- tab
  }


for (i in num_confounds[c(-1)]) {
  tmp<-shapiro.test(map[,i])
  if (tmp$p.value <= 0.05) {
    res<-wilcox.test(as.formula(paste(i, "~ phenotype")), data=map, var.equal = FALSE)
    tab<-tibble(i, res$p.value, "wilcox")
    colnames(tab) <- c("Var", "p.value", "Type")
    numerical_test_btwn_pheno <-rbind(numerical_test_btwn_pheno, tab)
  }else{
    res<-t.test(as.formula(paste(i, "~ phenotype")), data=map)
    tab<-tibble(i, res$p.value, "t.test")
    colnames(tab) <- c("Var", "p.value", "Type")
    numerical_test_btwn_pheno <-rbind(numerical_test_btwn_pheno, tab)
  }
}


numerical_test_btwn_pheno$p.value<-p.adjust(numerical_test_btwn_pheno$p.value)
sig_numvar<-numerical_test_btwn_pheno[which(numerical_test_btwn_pheno$p.value <= 0.05),]

num_confounds2 <- sig_numvar$Var






#Spearman test between taxa and possible confounding variables that are ordinal
confound <- num_confounds2[1]  
otus<-as.data.frame(otu_table(ps_DeSeq_norm_pass_min_postDD_sup003))
otus <- t(otus)
otus <- as.data.frame(otus)

otus$confound <- map[,confound]
form <-as.formula(paste("~", colnames(otus)[1], "+", "confound"))
tmp<-cor.test(formula = form, data = otus, method = "spearman",
         continuity = FALSE,
         conf.level = 0.95, exact = FALSE)

speartesttab <- tibble(colnames(otus)[1], tmp$p.value)
colnames(speartesttab) <- c("otu", "p_val")

for (i in 2:(length(colnames(otus))-1)){
    otus$confound <- map[,confound]
    form <-as.formula(paste("~", colnames(otus)[i], "+", "confound"))
    tmp<-cor.test(formula = form, data = otus, method = "spearman",
         continuity = FALSE,
         conf.level = 0.95, exact = FALSE)

    tab <- tibble(colnames(otus)[i], tmp$p.value)
    colnames(tab) <- c("otu", "p_val")
    speartesttab <-rbind(speartesttab, tab)
}

spear_p.val<-p.adjust(speartesttab$p_val)
spear_sig_asvs_p.val<-speartesttab$otu[spear_p.val < 0.05]

for (x in 2:length(num_confounds2)){
  confound <- num_confounds2[x]  
  otus<-as.data.frame(otu_table(ps_DeSeq_norm_pass_min_postDD_sup003))
  otus <- t(otus)
  otus <- as.data.frame(otus)

  otus$confound <- map[,confound]
  form <-as.formula(paste("~", colnames(otus)[1], "+", "confound"))
  tmp<-cor.test(formula = form, data = otus, method = "spearman",
         continuity = FALSE,
         conf.level = 0.95, exact = FALSE)

  speartesttab <- tibble(colnames(otus)[1], tmp$p.value)
  colnames(speartesttab) <- c("otu", "p_val")

  for (i in 2:(length(colnames(otus))-1)){
    otus$confound <- map[,confound]
    form <-as.formula(paste("~", colnames(otus)[i], "+", "confound"))
    tmp<-cor.test(formula = form, data = otus, method = "spearman",
         continuity = FALSE,
         conf.level = 0.95, exact = FALSE)

    tab <- tibble(colnames(otus)[i], tmp$p.value)
    colnames(tab) <- c("otu", "p_val")
    speartesttab <-rbind(speartesttab, tab)
}

  spear_p.val<-p.adjust(speartesttab$p_val)
  spear_sig_asvs_p.val<-c(spear_sig_asvs_p.val, speartesttab$otu[spear_p.val < 0.05])

}

affected_num_list <- unique(spear_sig_asvs_p.val)

full_confound_asv_list <-c(affected_num_list, affected_taxa_cat)

full_confound_asv_list<-unique(full_confound_asv_list)

full_sigtab_esv_confoundfiltered<-fullsigtab_esv[-which(rownames(fullsigtab_esv) %in% full_confound_asv_list), ]

write.csv(full_sigtab_esv_confoundfiltered, "Full_sig_asvs_w_confounding_var_asvs_filtered_out.csv")

confounding_var_list <-c(num_confounds2, cat_confounds)
saveRDS(confounding_var_list, "confounding_var_list.rds")


full_sigtab_esv_confoundfiltered.print <- full_sigtab_esv_confoundfiltered
rownames(full_sigtab_esv_confoundfiltered.print) <- NULL
full_sigtab_esv_confoundfiltered.print$ASV <- NULL

full_sigtab_esv_confoundfiltered.print


```
### Digital phenotype
```{r pcoa_dig_phenotype, fig.height=5}
sample_data(ps_DeSeq_norm_pass_min_postDD_sup003)$Mobile.Autism.Risk.Assessment.Score <- as.numeric(sample_data(ps_DeSeq_norm_pass_min_postDD_sup003)$Mobile.Autism.Risk.Assessment.Score)

wo_na_pcoa(ps_DeSeq_norm_pass_min_postDD_sup003, 'Mobile.Autism.Risk.Assessment.Score', GP.ord)
```

### Probiotics
```{r pcoa_probiotics, fig.height=5}
wo_na_pcoa(ps_DeSeq_norm_pass_min_postDD_sup003, 'Probiotic..consumption.frequency.', GP.ord)
```

### Antibiotics
```{r pcoa_antibiotics, fig.height=5}
# Anti.infective
wo_na_pcoa(ps_DeSeq_norm_pass_min_postDD_sup003, 'Anti.infective', GP.ord)

# Minimum.time.since.antibiotics
sample_data(ps_DeSeq_norm_pass_min_postDD_sup003)$Minimum.time.since.antibiotics <- as.numeric(sample_data(ps_DeSeq_norm_pass_min_postDD_sup003)$Minimum.time.since.antibiotics)
wo_na_pcoa(ps_DeSeq_norm_pass_min_postDD_sup003, 'Minimum.time.since.antibiotics', GP.ord)

```

### All other passed R2 cutoff and significant
```{r pcoa_permanova_sig, fig.height=5}

for(pvar in permanova_res[R2>permanova_cut & pvalue<permanova_pcut]$Variable){
wo_na_pcoa(ps_DeSeq_norm_pass_min_postDD_sup003, pvar, GP.ord)
}

```


# Session information

```{r sessionInfo}
sessionInfo()
```


