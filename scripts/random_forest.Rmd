---
title: "random_forest"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
setwd("~/Tree_M3_datasets/M3_Phyloseq_Analysis_breastfedout//scripts/")
library(caret)
library(randomForest)
library(tibble)
library(ROCR)
library(dplyr)
library(reshape2)
library(phyloseq)
library(glmnet)
library(stringr)
library(ggpubr)
source('../clean_mapping_ml.R')
```

# Load data
```{r}
output_data <- "../results/"
ps_not_norm_comp <- readRDS("../data/ps_not_norm_age_filter_complete_family.rds")
ps_deseq <- readRDS(paste0(output_data, "Filtered/ps_deseq_friedfilt.rds"))
ps_css <- readRDS(paste0(output_data, "Filtered/ps_css_friedfilt.rds"))
sig_res <- read.table(paste0(output_data, "significant_taxa_timeseries.tsv"), row.names = 1, sep = "\t", header = T)
sig_res_all <- read.table(paste0(output_data, "significant_taxa_all.tsv"), row.names = 1, sep = "\t", header = T)
```
### Will remake DESeq2 sam_data for the following code to work (metadata formatting was changed in norm obj, and this obj isnt compatible with current code unless following chunk is used)

```{r}
ps_not_norm_comp <- readRDS("../data/ps_not_norm_age_filter_complete_family.rds")

#Remove Breastfed and their families
breast_fed <- c("089_A","054_N", "158_N" )

b_fed<-unique(ps_not_norm_comp@sam_data$Family.group.ID[which(ps_not_norm_comp@sam_data$Host.Name %in% breast_fed)])

#remove the whole family
for (i in b_fed){
  ps_not_norm_comp<- prune_samples(ps_not_norm_comp@sam_data$Family.group.ID != i, ps_not_norm_comp)

}


#Remove Possible Contradictions and their families
possible_phen_contra <- c("020_A","131_A", "184_A" )

p_con<-unique(ps_not_norm_comp@sam_data$Family.group.ID[which(ps_not_norm_comp@sam_data$Host.Name %in% possible_phen_contra)])

#remove the whole family
for (i in p_con){
  ps_not_norm_comp<- prune_samples(ps_not_norm_comp@sam_data$Family.group.ID != i, ps_not_norm_comp)

}

ps_deseq@sam_data<-sample_data(ps_not_norm_comp)

```


### metadata for ML
```{r echo = F, results = 'hide'}

map_keep <- keepImportantColumns(ps_deseq@sam_data, metabol = F)
rownames(map_keep) <- map_keep$biospecimen_id
write.csv(map_keep, file = "../data/map_keep.csv")
map_keep<-read.csv(file = "../data/map_keep.csv", row.names = "X")

#Added makeFieldNumeric already in the filtering_normalization.rmd, so not needed here, so will omit
map_num <- makeFieldsNumeric(map_keep)
#select doesnt work for my session for some reason
#map_num <-map_num %>% select(-c(MARA, date))
map_num <- map_num[,-which(colnames(map_num) %in% c("MARA", "date"))]
nums <- as.vector(unlist(lapply(map_num, is.numeric)) )
map_num[, !nums] <- lapply(map_num[, !nums], factor)
map_num$stool_freq <- as.numeric(map_num$stool_freq)
sample_data(ps_deseq) <- map_num

```

### Random Forest

```{r randomforest}
#Random Forest main function
rand_forest <- function(pred_sequences, ps, include_taxa = T, include_meta = F){ 
  set.seed(1)
  phen <- sample_data(ps)$phenotype
  fam_id <- sample_data(ps)$familyID
  data <- NULL
  if(include_taxa){
    ps <- prune_taxa(pred_sequences, ps )
    data <- t(otu_table(ps))
    
    #taxa names for plot labels
    species_names <- as.character(ps@tax_table[, 7])
    genus_names <- as.character(ps@tax_table[, 6])
    family_names <- as.character(ps@tax_table[, 5])
    taxa <- species_names
    taxa[taxa == "s__unclassified"] = genus_names[taxa == "s__unclassified"]
    taxa[taxa == "g__unclassified"] = family_names[taxa == "g__unclassified"]
    colnames(data) <- taxa
    
  }
  if(include_meta){
    metadata <- data.frame(ps@sam_data)
    metadata <- metadata %>% select(-c(familyID, biospecimen_id, biospecimen_name, host_name, timepoint, age, dietary_restriction, dietary_supplement, sex, probiotic, vitamin_B, vitamin_D, multivitamin, racial_group))
    metadata <- rfImpute(phenotype ~., metadata)
    metadata <- metadata %>% select(-c(phenotype))
    if(is.null(data)){
      data <- metadata
    }else{
      data <- data.frame(cbind(data, metadata))
    }
  }
  data <- data.frame(phen, data, fam_id)
  
  
  folds_by_family <- groupKFold(fam_id, 5)
  data <- data %>% select(-c(fam_id))
  
  validate <- data[-folds_by_family[[1]],]
  training <- data[folds_by_family[[1]],]
  

  
  control <- trainControl(method='repeatedcv', 
                        number=3, 
                        repeats=3)

  tree_depths <- round(seq(2, ncol(data), by = ncol(data) / 6))
  tunegrid <- expand.grid(.mtry= tree_depths) #mtry is the depth of each decision tree
  
  rf <- train(phen ~., 
            data = training, 
            method='rf', 
            metric='Accuracy', 
            tuneGrid=tunegrid, 
            trControl=control)


  mtry_best = as.numeric(rf$bestTune)
  print(paste0("Tree depth: ", mtry_best))

  pred_votes <- c()
  outputlist <- list()
  for(i in 1:10){
    AR.classify <- randomForest(phen~., data = training, ntree = 128, mtry = mtry_best, importance = TRUE)
    rf <- AR.classify
    OOB.votes <- predict(rf, validate[,-1], type="prob");
    OOBpred_votes <- OOB.votes
  
    pred_votes <-  OOBpred_votes[,2]
    pred.obj <- prediction(pred_votes, data[names(pred_votes), ]$phen)
    
    #roc (tpr / fpr) perforamnce 
    roc_perf <- performance(pred.obj,"tpr", "fpr") #Calculate the AUC value
    auc_roc <- performance(pred.obj, "auc")@y.values[[1]]
    
    
    perf_obj <-list()
    perf_obj[[1]] <- auc_roc
    perf_obj[[2]] <- roc_perf
    perf_obj[[3]] <- rf
    outputlist[[i]] <- perf_obj
  }
  return(outputlist)
}
```



```{r}
plotAUCs <- function(perf_obj, col_ind = 1, plot_name = ""){
  avg_auc <- mean(unlist(lapply(perf_obj, function(x) return(x[[1]]))))
  plot(perf_obj[[1]][[2]], col = rainbow(8)[col_ind])
  for(i in 2:length(perf_obj)){
    plot(perf_obj[[i]][[2]], col = rainbow(8)[col_ind], add = T)   
  }
  abline(a=0, b= 1)
  text(.9, .1, paste0("AUC: ", round(avg_auc, 3)))
  title(plot_name)
  print(avg_auc)
}

plotAUCs_multiple <- function(perf_obj_list, plot_name = ""){
  j = 1
  add = F
  for(perf_obj in perf_obj_list){
    col_ind = j
    avg_auc <- mean(unlist(lapply(perf_obj, function(x) return(x[[1]]))))
    if(j>1){
      add = T
    }
    plot(perf_obj[[1]][[2]], col = rainbow(8)[col_ind], add = add)
    #for(i in 2:length(perf_obj)){
    #  plot(perf_obj[[i]][[2]], col = rainbow(8)[col_ind], add = add)   
    #}
    abline(a=0, b= 1)
    text(.9, .1, paste0("AUC: ", round(avg_auc, 3)))
    j = j + 1
  }
  legend("bottomright", legend = c("Meta", "Meta + markers", "Meta + null"), fill = c(rainbow(8)[1], rainbow(8)[2], rainbow(8)[3]))

}
```



### Just metadata
```{r fig.height = 3, fig.width=5, echo = F}

perf_obj_meta <- rand_forest(pred_sequences = NA, ps = ps_deseq, include_taxa = F, include_meta = T)
plotAUCs(perf_obj_meta, 1, "Just Metadata")
```

```{r, fig.height = 6, fig.width = 7}
varImpPlot(perf_obj_meta[[1]][[3]])
```

### Metadata and taxa selected by two methods in mixed effect model
```{r fig.height = 3, fig.width=5}
use <- grepl(",", sig_res$method)
perf_obj_biomarkers <- rand_forest(pred_sequences = rownames(sig_res)[use], ps = ps_deseq, include_taxa = T, include_meta = T)
plotAUCs(perf_obj_biomarkers, 3, "Taxa selected two methods timeseries and metadata")
```

```{r, fig.height = 10, fig.width = 12}
#average importance over all 10 trees
imp_list <- list()
i = 1
for(obj in perf_obj_biomarkers){
  model = obj[[3]]
  imp_list[[i]] <- data.frame(importance(model)) %>% select(-c("A", "N"))
  i = i + 1
}

imp_df <- do.call(cbind.data.frame, imp_list)
imp_df$lifestyle_variable <- rownames(imp_df)
melted <- melt(imp_df)
melted_gini <- melted[melted$variable == "MeanDecreaseGini", ]
melted_acc <- melted[melted$variable == "MeanDecreaseAccuracy", ]
ggplot(melted_gini, aes(x = reorder(lifestyle_variable, value), y = value)) +
  geom_boxplot() + geom_jitter(width = .2) + coord_flip() + theme_bw()

ggplot(melted_acc, aes(x = reorder(lifestyle_variable, value), y = value)) +
  geom_boxplot() + geom_jitter(width = .002) + coord_flip() + theme_bw()

```
### Metadata and 11 randomly selected taxa
```{r fig.height = 3, fig.width=5}
set.seed(1)
amt <- grepl(",", sig_res$method)
use <- sample(taxa_names(ps_deseq)[-which(taxa_names(ps_deseq) %in% rownames(sig_res)[amt])], length(rownames(sig_res)[amt]))
perf_obj_rand <- rand_forest(pred_sequences = use, ps = ps_deseq, include_taxa = T, include_meta = T)
plotAUCs(perf_obj_rand, 3, "11 randomly selected taxa and metadata")
```

### Metadata and 11 randomly selected taxa (new seed = 2)
```{r fig.height = 3, fig.width=5}
set.seed(2)
amt <- grepl(",", sig_res$method)
use <- sample(taxa_names(ps_deseq)[-which(taxa_names(ps_deseq) %in% rownames(sig_res)[amt])], length(rownames(sig_res)[amt]))
perf_obj_rand2 <- rand_forest(pred_sequences = use, ps = ps_deseq, include_taxa = T, include_meta = T)
plotAUCs(perf_obj_rand2, 3, "11 randomly selected taxa and metadata (Subset_2)")
```

### Metadata and 11 randomly selected taxa (new seed = 3)
```{r fig.height = 3, fig.width=5}
set.seed(3)
amt <- grepl(",", sig_res$method)
use <- sample(taxa_names(ps_deseq)[-which(taxa_names(ps_deseq) %in% rownames(sig_res)[amt])], length(rownames(sig_res)[amt]))
perf_obj_rand3 <- rand_forest(pred_sequences = use, ps = ps_deseq, include_taxa = T, include_meta = T)
plotAUCs(perf_obj_rand3, 3, "11 randomly selected taxa and metadata (Subset_3)")
```

### Plot comparison
```{r, fig.width= 5, fig.height = 5}
auc_meta <- lapply(perf_obj_meta, function(x) return(x[[1]]))
auc_meta_bio <- lapply(perf_obj_biomarkers, function(x) return(x[[1]]))
auc_meta_null <- lapply(perf_obj_rand, function(x) return(x[[1]]))
auc_meta_null_set2 <- lapply(perf_obj_rand2, function(x) return(x[[1]]))
auc_meta_null_set3 <- lapply(perf_obj_rand3, function(x) return(x[[1]]))
df <- data.frame('meta' = unlist(auc_meta), 'meta_bio' = unlist(auc_meta_bio), 'meta_null' = unlist(auc_meta_null), 'meta_null_set2' = unlist(auc_meta_null_set2), 'meta_null_set3' = unlist(auc_meta_null_set3))
my_comparison <- list(c("meta", "meta_bio"), c("meta","meta_null"), c("meta_bio","meta_null"), c("meta_bio","meta_null_set2"), c("meta_bio","meta_null_set3"))
#, c("meta_null","meta_null_set2"), c("meta_null","meta_null_set3"), c("meta","meta_null_set2"), c("meta","meta_null_set3"), c("meta_null_set2","meta_null_set3"))
ggplot(melt(df), aes(x = variable, y = value, color = variable)) + geom_boxplot() + geom_jitter(width = .2) + theme_bw() +stat_compare_means(comparisons = my_comparison, label = "p.signif", hide.ns = TRUE)

#ns: p > 0.05
#*: p <= 0.05
#**: p <= 0.01
#***: p <= 0.001
#****: p <= 0.0001

```


# Other models not reported in paper for sake on being concise

### All significant taxa in timeseries without metadata
```{r, fig.height = 3, fig.width=5}
set.seed(1)
perf_obj_allsig <- rand_forest(pred_sequences = rownames(sig_res), ps = ps_deseq, include_taxa = T, include_meta = F)
plotAUCs(perf_obj_allsig, 1, "All Sig Taxa timeseries without metadata")
```

### Just in two or more timeseries and null equivalent
```{r fig.height = 3, fig.width=5}
set.seed(1)
use <- grepl(",", sig_res$method)
perf_obj_biomarkers <- rand_forest(pred_sequences = rownames(sig_res)[use], ps = ps_deseq, include_taxa = T, include_meta = F)
plotAUCs(perf_obj_biomarkers, 3, "Taxa selected two methods timeseries, no metadata")

set.seed(1)
amt <- grepl(",", sig_res$method)
use <- sample(taxa_names(ps_deseq)[-which(taxa_names(ps_deseq) %in% rownames(sig_res))], length(rownames(sig_res)[amt]))
perf_obj_rand <- rand_forest(pred_sequences = use, ps = ps_deseq, include_taxa = T, include_meta = F)
plotAUCs(perf_obj_rand, 3, "15 randomly selected taxa, no metadata")
```
```

### Metadata and taxa selected by at least one method in mixed effect model (i.e. timepoint in formula)
```{r fig.height = 3, fig.width=5}
perf_obj_0 <- rand_forest(pred_sequences = rownames(sig_res), ps = ps_deseq, include_taxa = T, include_meta = T)
plotAUCs(perf_obj_0, 2, 'Taxa selected one method timeseries and metadata')
```

### Metadata and all taxa selected at any timepoint
```{r, fig.height = 3, fig.width=5}
perf_obj_2 <- rand_forest(pred_sequences = rownames(sig_res_all), ps = ps_deseq, include_taxa = T, include_meta = T)
plotAUCs(perf_obj_2, 4, "Taxa at any timepoint and metadata")
```

### Metadata and all taxa selected at 2 or more timepoints
```{r, fig.height = 3, fig.width=5}
use <- str_count(sig_res_all$enrichment, "Aut") >= 4
perf_obj_2 <- rand_forest(pred_sequences = rownames(sig_res_all), ps = ps_deseq, include_taxa = T, include_meta = T)
plotAUCs(perf_obj_2, 4, "Taxa 4 or more timepoints and metadata")
```




### Taxa in either timeseries without metadata
```{r, fig.height = 3, fig.width=5}
#use <- !is.na(sig_res$deseq_timeseries_adjp) | !is.na(sig_res$mtgseq_timeseries_adjp)
#sig_res has no "deseq_timeseries_adj" column or mtgseq one, will do work around
#since sig_res is only consisted of ones in either time series, should be okay to use all
perf_obj_allsig <- rand_forest(pred_sequences = rownames(sig_res), ps = ps_deseq, include_taxa = T, include_meta = F)
plotAUCs(perf_obj_allsig, 2, "All Sig Taxa")
```



### Variance in phenotype explained by most informative taxa by logistic regression
```{r}
runLogisticRegression <- function(pred_sequences, ps){
  set.seed(1)
  ps <- prune_taxa(pred_sequences, ps )
  folds_by_family <- groupKFold(ps@sam_data$familyID, 5)
  train <- t(ps@otu_table[, -folds_by_family[[1]]])
  test <- t(ps@otu_table[, folds_by_family[[1]]])
  train_y <- ps@sam_data$phenotype[-folds_by_family[[1]]]
  test_y <- ps@sam_data$phenotype[folds_by_family[[1]]]
  cvfit <- cv.glmnet(as.matrix(train), train_y, family = "binomial")
  preds <- predict(cvfit, test, s = 'lambda.min')
  pred.obj <- prediction(preds, test_y)
      
    #roc (tpr / fpr) perforamnce 
  roc_perf <- performance(pred.obj,"tpr", "fpr") #Calculate the AUC value
  auc_roc <- performance(pred.obj, "auc")@y.values[[1]]
  print(auc_roc)
}


```

```{r}
runLogisticRegression(taxa_names(ps_deseq), ps_deseq)
```

```{r}
use <- as.numeric(apply(sig_res, 1, function(x) return(sum(!is.na(x))))) > 0
runLogisticRegression(rownames(sig_res)[use], ps_deseq)
```

```{r}
use <- as.numeric(apply(sig_res, 1, function(x) return(sum(!is.na(x))))) > 1
runLogisticRegression(rownames(sig_res)[use], ps_deseq)
```

```{r}
#Similar issues to 266, will use weird workaround
#use <- !is.na(sig_res$deseq_timeseries_adjp) & !is.na(sig_res$mtgseq_timeseries_adjp)
use <- sig_res$method  %in% c("DESEQ_time" , "ZIG_time" , "ANCOM_time") == FALSE
runLogisticRegression(rownames(sig_res)[use], ps_deseq)
```
```{r}
#use <- !is.na(sig_res$deseq_timeseries_adjp) | !is.na(sig_res$mtgseq_timeseries_adjp)
#since sig_res is only consisted of ones in either time series, should be okay to use all
#Similar issues to 266, will use weird workaround

runLogisticRegression(rownames(sig_res), ps_deseq)
```


### Stool frequency
```{r fig.height = 3, fig.width=3}
aut <- ps_deseq@sam_data$phenotype == "A"
nt <- ps_deseq@sam_data$phenotype == "N"
boxplot(ps_deseq@sam_data$stool_freq[aut], ps_deseq@sam_data$stool_freq[nt])
```


### Heat Map
```{r heat map, fig.height = 10}
ps_tss <- readRDS("../results/Normalized/ps_tss_pass_min_postDD_min0.03.rds")
# Heatmap EXPERIMENTAL STAGE
heatmap <- ps_tss@otu_table[rownames(sig_res),]
heatlabel <- gsub("g__","",sig_res$Genus)
for (x in 1:70){
  if (heatlabel[x] == "unclassified"){
    heatlabel[x]<-paste(gsub("c__", "", sig_res$Class[x]), heatlabel[x], sep = "_")
  }
  heatlabel[x] <- paste(heatlabel[x], x, sep = ".")
}

rownames(heatmap) <- heatlabel
heatmap<-as.data.frame(heatmap)
heatmap <- t(heatmap)
heatmap<-as.data.frame(heatmap)
heatmap$Sample <- rownames(heatmap)
heatmap$Phenotype <- ps_tss@sam_data$phenotype
heatmap_below0.5 <- heatmap
maxes<-list()
for (x in c(1:70)){
   maxes[x]<-max(heatmap_below0.5[,x])
}
heatmap_below0.5 <- heatmap[,-which(maxes >= 0.002)]

heatmelt <-melt(heatmap_below0.5, value.name = "Abundance")
ggplot(heatmelt, aes(Sample, variable, fill= Abundance)) + 
  geom_tile() + 
  facet_grid(~ Phenotype,switch = "x", scales = "free_x", space = "free_x") +
  scale_fill_gradient(name = "Abundance",
                      low = "#FFFFFF",
                      high = "#012345")



```